[{"filePath":"/Users/issiki_sigeo/Library/CloudStorage/OneDrive-公益社団法人神奈川県社会福祉士会/ドキュメント/kintone/アプリ開発/my-first-static-web-app/src/character_handling.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":520,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":520,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** 文字列処理をまとめたJavaScriptの関数群です。\n * @author Shigeo Isshiki <issiki@kacsw.or.jp>\n * @version 1.1.0\n */\n// 関数命名ルール: 外部に見せる関数名はそのまま、内部で使用する関数名は(_ch_)で始める\n/* exported convert_to_hiragana, convert_to_double_byte_characters, convert_to_email_address, check_single_byte_numbers */\n'use strict';\n/**\n * 文字列が文字列型であることを確認する関数\n * @param {*} str - 確認する文字列\n * @returns {boolean} - 文字列である = true、文字でない = false\n */\nconst _ch_checkString = (str) => {\n  return typeof str === 'string' && str !== null && str !== undefined;\n};\n/**\n * 変換用の文字リスト\n * 各種文字の変換ルールを定義します。\n * ひらがな、カタカナ、濁点・半濁点の変換をサポートします。\n * @typedef {object} _ch_convert_character_list\n * @property {object} half_width_kana 全角カタカナから半角カタカナへの変換マップ\n * @property {object} full_width_kana 半角カタカナから全角カタカナへの変換マップ\n * @property {object} turbidity_kana 濁点・半濁点の変換マップ\n */\n/** @type {_ch_convert_character_list} */\nconst _ch_convert_character_list = {\n  half_width_kana: {\n    ア: 'ｱ',\n    イ: 'ｲ',\n    ウ: 'ｳ',\n    エ: 'ｴ',\n    オ: 'ｵ',\n    カ: 'ｶ',\n    キ: 'ｷ',\n    ク: 'ｸ',\n    ケ: 'ｹ',\n    コ: 'ｺ',\n    サ: 'ｻ',\n    シ: 'ｼ',\n    ス: 'ｽ',\n    セ: 'ｾ',\n    ソ: 'ｿ',\n    タ: 'ﾀ',\n    チ: 'ﾁ',\n    ツ: 'ﾂ',\n    テ: 'ﾃ',\n    ト: 'ﾄ',\n    ナ: 'ﾅ',\n    ニ: 'ﾆ',\n    ヌ: 'ﾇ',\n    ネ: 'ﾈ',\n    ノ: 'ﾉ',\n    ハ: 'ﾊ',\n    ヒ: 'ﾋ',\n    フ: 'ﾌ',\n    ヘ: 'ﾍ',\n    ホ: 'ﾎ',\n    マ: 'ﾏ',\n    ミ: 'ﾐ',\n    ム: 'ﾑ',\n    メ: 'ﾒ',\n    モ: 'ﾓ',\n    ヤ: 'ﾔ',\n    ユ: 'ﾕ',\n    ヨ: 'ﾖ',\n    ラ: 'ﾗ',\n    リ: 'ﾘ',\n    ル: 'ﾙ',\n    レ: 'ﾚ',\n    ロ: 'ﾛ',\n    ワ: 'ﾜ',\n    ヲ: 'ｦ',\n    ン: 'ﾝ',\n    ガ: 'ｶﾞ',\n    ギ: 'ｷﾞ',\n    グ: 'ｸﾞ',\n    ゲ: 'ｹﾞ',\n    ゴ: 'ｺﾞ',\n    ザ: 'ｻﾞ',\n    ジ: 'ｼﾞ',\n    ズ: 'ｽﾞ',\n    ゼ: 'ｾﾞ',\n    ゾ: 'ｿﾞ',\n    ダ: 'ﾀﾞ',\n    ヂ: 'ﾁﾞ',\n    ヅ: 'ﾂﾞ',\n    デ: 'ﾃﾞ',\n    ド: 'ﾄﾞ',\n    バ: 'ﾊﾞ',\n    ビ: 'ﾋﾞ',\n    ブ: 'ﾌﾞ',\n    ベ: 'ﾍﾞ',\n    ボ: 'ﾎﾞ',\n    パ: 'ﾊﾟ',\n    ピ: 'ﾋﾟ',\n    プ: 'ﾌﾟ',\n    ペ: 'ﾍﾟ',\n    ポ: 'ﾎﾟ',\n    ヴ: 'ｳﾞ',\n    ヷ: 'ﾜﾞ',\n    ヺ: 'ｦﾞ',\n    ァ: 'ｧ',\n    ィ: 'ｨ',\n    ゥ: 'ｩ',\n    ェ: 'ｪ',\n    ォ: 'ｫ',\n    ッ: 'ｯ',\n    ャ: 'ｬ',\n    ュ: 'ｭ',\n    ョ: 'ｮ',\n    '゛': 'ﾞ',\n    '゜': 'ﾟ',\n    '　': ' ',\n  },\n  full_width_kana: {\n    ｱ: 'ア',\n    ｲ: 'イ',\n    ｳ: 'ウ',\n    ｴ: 'エ',\n    ｵ: 'オ',\n    ｶ: 'カ',\n    ｷ: 'キ',\n    ｸ: 'ク',\n    ｹ: 'ケ',\n    ｺ: 'コ',\n    ｻ: 'サ',\n    ｼ: 'シ',\n    ｽ: 'ス',\n    ｾ: 'セ',\n    ｿ: 'ソ',\n    ﾀ: 'タ',\n    ﾁ: 'チ',\n    ﾂ: 'ツ',\n    ﾃ: 'テ',\n    ﾄ: 'ト',\n    ﾅ: 'ナ',\n    ﾆ: 'ニ',\n    ﾇ: 'ヌ',\n    ﾈ: 'ネ',\n    ﾉ: 'ノ',\n    ﾊ: 'ハ',\n    ﾋ: 'ヒ',\n    ﾌ: 'フ',\n    ﾍ: 'ヘ',\n    ﾎ: 'ホ',\n    ﾏ: 'マ',\n    ﾐ: 'ミ',\n    ﾑ: 'ム',\n    ﾒ: 'メ',\n    ﾓ: 'モ',\n    ﾔ: 'ヤ',\n    ﾕ: 'ユ',\n    ﾖ: 'ヨ',\n    ﾗ: 'ラ',\n    ﾘ: 'リ',\n    ﾙ: 'ル',\n    ﾚ: 'レ',\n    ﾛ: 'ロ',\n    ﾜ: 'ワ',\n    ｦ: 'ヲ',\n    ﾝ: 'ン',\n    ｧ: 'ァ',\n    ｨ: 'ィ',\n    ｩ: 'ゥ',\n    ｪ: 'ェ',\n    ｫ: 'ォ',\n    ｯ: 'ッ',\n    ｬ: 'ャ',\n    ｭ: 'ュ',\n    ｮ: 'ョ',\n    ﾞ: '゛',\n    ﾟ: '゜',\n    ' ': '　',\n  },\n  turbidity_kana: {\n    'カ゛': 'ガ',\n    'キ゛': 'ギ',\n    'ク゛': 'グ',\n    'ケ゛': 'ゲ',\n    'コ゛': 'ゴ',\n    'サ゛': 'ザ',\n    'シ゛': 'ジ',\n    'ス゛': 'ズ',\n    'セ゛': 'ゼ',\n    'ソ゛': 'ゾ',\n    'タ゛': 'ダ',\n    'チ゛': 'ヂ',\n    'ツ゛': 'ヅ',\n    'テ゛': 'デ',\n    'ト゛': 'ド',\n    'ハ゛': 'バ',\n    'ヒ゛': 'ビ',\n    'フ゛': 'ブ',\n    'ヘ゛': 'ベ',\n    'ホ゛': 'ボ',\n    'ハ゜': 'パ',\n    'ヒ゜': 'ピ',\n    'フ゜': 'プ',\n    'ヘ゜': 'ペ',\n    'ホ゜': 'ポ',\n    'ウ゛': 'ヴ',\n    'ワ゛': 'ヷ',\n    'ヲ゛': 'ヺ',\n  },\n};\n\n// 公開（kintone側でグローバル参照される可能性のあるシンボルを window に露出）\nif (typeof window !== 'undefined') {\n  window.convert_to_hiragana = convert_to_hiragana;\n  window.convert_to_double_byte_characters = convert_to_double_byte_characters;\n  window.convert_to_email_address = convert_to_email_address;\n  window.check_single_byte_numbers = check_single_byte_numbers;\n  window.check_single_byte_kana = check_single_byte_kana;\n  window.assertEmailAddress = assertEmailAddress;\n}\n/**\n * イテラブルな文字列集合から正規表現パターンを構築する関数\n * @param {Iterable<string>} keys イテラブルな文字列集合\n * @returns {RegExp} 正規表現のパターン\n */\nconst _ch_buildPattern = (keys) => {\n  if (!keys) throw new Error('keys is required');\n  const escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  if (!(keys && typeof keys[Symbol.iterator] === 'function'))\n    throw new Error('keys must be an Iterable');\n  const escapedKeys = [...keys].map(escapeRegExp);\n  return new RegExp(escapedKeys.join('|'), 'g');\n};\n/**\n * 半角カタカナ変換用のマップを作成する\n */\nconst _ch_halfWidthKanaMap = new Map(Object.entries(_ch_convert_character_list.half_width_kana));\n/**\n * 全角カタカナ変換用のマップを作成する\n */\nconst _ch_full_width_kana_map = new Map(Object.entries(_ch_convert_character_list.full_width_kana));\n/**\n * 濁点・半濁点変換用のマップを作成する\n */\nconst _ch_turbidity_kana_map = new Map(Object.entries(_ch_convert_character_list.turbidity_kana));\n/**\n * 文字列を正規表現で表記されたパターンに一致した場合、マップにある文字列に置き換える処理をする関数\n * @param {string} str 変換対象の文字列\n * @param {RegExp} pattern 正規表現のパターン\n * @param {Map} map 置き換えマップ\n * @returns {string} 置き換え後の文字列\n */\nconst _ch_replace_with_map = (str, pattern, map) => {\n  if (!_ch_checkString(str))\n    throw new Error(`_ch_replace_with_mapの[${str}]は文字である必要があります`);\n  if (!(pattern instanceof RegExp)) throw new Error('pattern must be a RegExp');\n  if (!(map instanceof Map)) throw new Error('map must be a Map');\n  return str.replace(pattern, (char) => map.get(char) ?? char);\n};\n\n/**\n * 文字列の中の各文字を半角カタカナに変換する関数\n * @param {string} str 変換対象の文字列\n * @returns {string} 可能な限り半角カタカナに変換した文字列\n */\nconst convert_to_half_width_kana = (str = '') => {\n  if (!_ch_checkString(str)) return '';\n  const half_width_kana_pattern = _ch_buildPattern(_ch_halfWidthKanaMap.keys());\n  return _ch_replace_with_map(str, half_width_kana_pattern, _ch_halfWidthKanaMap);\n};\n\n/**\n * 文字列の中の各文字を全角カタカナに変換する関数\n * @param {string} str 変換対象の文字列\n * @param {boolean} hiragana_sw ひらがな変換の可否を選択するスイッチ（trueで変換、falseで不変換）\n * @returns {string} 可能な限り全角カタカナに変換した文字列\n */\nconst convert_to_full_width_kana = (str = '', hiragana_sw = true) => {\n  if (!_ch_checkString(str)) return '';\n  if (typeof hiragana_sw !== 'boolean') return '';\n  const hiraganaToKatakana = (str) => {\n    return str.replace(/[\\u3041-\\u3096]/g, (char) =>\n      String.fromCodePoint(char.charCodeAt(0) + 0x60)\n    );\n  };\n  const full_width_kana_pattern = _ch_buildPattern(_ch_full_width_kana_map.keys());\n  const turbidity_kana_pattern = _ch_buildPattern(_ch_turbidity_kana_map.keys());\n  let result = hiragana_sw ? hiraganaToKatakana(str) : str;\n  result = _ch_replace_with_map(result, full_width_kana_pattern, _ch_full_width_kana_map);\n  result = _ch_replace_with_map(result, turbidity_kana_pattern, _ch_turbidity_kana_map);\n  return result;\n};\n\n/**\n * 文字列の中の各文字をひらがなに変換する関数\n * @param {string} str 変換対象の文字列\n * @param {boolean} check ひらがな以外が含まれる場合はエラーを返すか選択するスイッチ（trueでエラーを返す、falseでエラーを返さない）\n * @returns {string} ひらがなに変換した文字列。エラー時は例外をスローします。\n */\nconst convert_to_hiragana = (str = '', check = false) => {\n  if (!_ch_checkString(str)) return '';\n  if (typeof check !== 'boolean') return '';\n  if (!str) return '';\n  const katakanaToHiragana = (str) => {\n    return str.replace(/[\\u30A1-\\u30F6]/g, (char) =>\n      String.fromCodePoint(char.charCodeAt(0) - 0x60)\n    );\n  };\n  const full_width_kana = convert_to_full_width_kana(str);\n  const hiragana = katakanaToHiragana(full_width_kana);\n  if (check) {\n    const allow_symbol = ['ー', '・', 'ゝ', 'ゞ', '゛', '゜', '　'];\n    const hiragana_check = [...hiragana].every(\n      (char) => (char >= 'ぁ' && char <= 'ん') || allow_symbol.includes(char)\n    );\n    if (!hiragana_check) {\n      throw new Error('ひらがな以外の文字が含まれています');\n    }\n  }\n  return hiragana;\n};\n\n/**\n * 文字列の中の各文字を半角文字（英数字・記号・スペース含む）に変換する関数\n * @param {string} str 変換対象の文字列\n * @returns {string} 半角文字に変換した文字列\n */\nconst convert_to_single_byte_characters = (str = '') => {\n  if (!_ch_checkString(str)) return '';\n  if (!str) return '';\n  const hyphen_processed = str.replace(/[－‐‑–—−ー―]/g, '-');\n  const half_width_kana = convert_to_half_width_kana(hyphen_processed);\n  const single_byte_characters = [...half_width_kana]\n    .map((char) => {\n      const code = char.charCodeAt(0);\n      if (\n        code >= 0xff01 &&\n        code <= 0xff5e // 全角記号・英数字\n      ) {\n        return String.fromCodePoint(code - 0xfee0);\n      }\n      if (char === '\\u3000') return ' '; // 全角スペースを半角に\n      return char;\n    })\n    .join('');\n  return single_byte_characters;\n};\n\n/**\n * 文字列の中の各文字を全角文字（英数字・記号・スペース含む）に変換する関数\n * @param {string} str 変換対象の文字列\n * @returns {string} 全角文字に変換した文字列\n */\nconst convert_to_double_byte_characters = (str = '') => {\n  if (!_ch_checkString(str)) return '';\n  if (!str) return '';\n  const hyphen_processed = str.replace(/[‐‑–—−ー―]/g, '－');\n  const full_width_kana = convert_to_full_width_kana(hyphen_processed, false);\n  const double_byte_characters = [...full_width_kana]\n    .map((char) => {\n      if (char === '\\\\') return '￥'; // 半角バックスラッシュを全角円マークに\n      if (char === ' ') return '\\u3000'; // 半角スペースを全角に\n      const code = char.charCodeAt(0);\n      if (\n        (code >= 0x21 && code <= 0x7e) || // 半角記号・英数字\n        (code >= 0x30 && code <= 0x39) || // 数字\n        (code >= 0x41 && code <= 0x5a) || // 英大文字\n        (code >= 0x61 && code <= 0x7a) // 英小文字\n      ) {\n        return String.fromCodePoint(code + 0xfee0);\n      }\n      return char;\n    })\n    .join('');\n  return double_byte_characters;\n\n  // 公開\n  if (typeof window !== 'undefined') {\n    window.convert_to_hiragana = convert_to_hiragana;\n    window.convert_to_double_byte_characters = convert_to_double_byte_characters;\n    window.convert_to_email_address = convert_to_email_address;\n    window.check_single_byte_numbers = check_single_byte_numbers;\n  }\n};\n\n/**\n * メールアドレスの表記を半角文字に変換した上で、RFC 5322に基づいた形式であるかを簡易判定する関数\n * @param {string} email_address メールアドレスとして変換対象の文字列\n * @returns {string} メールアドレス文字（メールアドレスとして正しくない場合は空白を返す）\n */\nconst convert_to_email_address = (email_address = '') => {\n  if (!_ch_checkString(email_address)) return '';\n  if (!email_address) return '';\n  // 前後空白除去\n  const trimmed = email_address.trim();\n  const single_byte_characters = convert_to_single_byte_characters(trimmed);\n  // 連続ドットや@直前・直後のドット禁止\n  if (/\\.\\.|^\\.|\\.@|@\\.|\\.$/.test(single_byte_characters)) return '';\n  const email_pattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n  return email_pattern.test(single_byte_characters) ? single_byte_characters : '';\n};\n\n/**\n * 文字列が半角数字のみ含まれるかをチェックする関数\n * @param {*} str チェック対象の文字列\n * @returns {boolean} 半角数字のみ含まれる場合はtrue、それ以外はfalse\n */\nconst check_single_byte_numbers = (str = '') => {\n  if ((typeof str !== 'string' && typeof str !== 'number') || str === null || str === undefined)\n    return false;\n  const number_pattern = /^[0-9]+$/;\n  return number_pattern.test(String(str));\n};\n\n/**\n * 文字列が半角カナ文字のみ含まれるかをチェックする関数\n * @param {string} str チェック対象の文字列\n * @returns {boolean} 半角カナ文字のみ含まれる場合はtrue、それ以外はfalse\n */\nconst check_single_byte_kana = (str = '') => {\n  if (!_ch_checkString(str)) return false;\n  const kana_pattern = /^[\\uFF61-\\uFF9F]+$/;\n  return kana_pattern.test(str);\n};\n\n/**\n * 文字列の中の各文字を半角カタカナに変換する関数\n * @param {string} str 変換対象の文字列\n * @param {boolean} [throwOnError=true] 変換不能な文字があった場合にエラーを投げるかどうか\n * @returns {string} 可能な限り半角カタカナに変換した文字列\n * @throws {Error} 変換不能な文字が含まれている場合（throwOnError=true時）\n */\nconst toHalfWidthKana = (str = '', throwOnError = true) => {\n  if (!_ch_checkString(str)) throw new Error('変換対象は文字列である必要があります');\n  if (!str) throw new Error('変換対象の文字列が空です');\n  const halfWidthKanaPattern = _ch_buildPattern(_ch_halfWidthKanaMap.keys());\n  let errorChar = null;\n  const result = str.replace(\n    halfWidthKanaPattern,\n    (char) => _ch_halfWidthKanaMap.get(char) ?? char\n  );\n  // 変換後に全角カタカナ・ひらがな・漢字・その他全角文字が残っていればエラー\n  for (const char of result) {\n    const code = char.charCodeAt(0);\n    if (\n      (code >= 0x4e00 && code <= 0x9fff) || // 漢字\n      (code >= 0x3040 && code <= 0x309f) || // ひらがな\n      (code >= 0x30a0 && code <= 0x30ff) || // カタカナ\n      (code >= 0xff00 && code <= 0xffef) // その他全角\n    ) {\n      if (throwOnError) {\n        errorChar = char;\n        break;\n      }\n    }\n  }\n  if (errorChar) throw new Error(`変換不能な文字が含まれています: ${errorChar}`);\n  return result;\n};\n\n/**\n * 文字列の中の各文字を半角文字（英数字・記号・スペース含む）に変換する関数\n * @param {string} str 変換対象の文字列\n * @param {boolean} [throwOnError=true] 変換不能な文字があった場合にエラーを投げるかどうか\n * @returns {string} 半角文字に変換した文字列\n * @throws {Error} 変換不能な文字が含まれている場合（throwOnError=true時）\n */\nconst toHalfWidth = (str = '', throwOnError = true) => {\n  if (!_ch_checkString(str)) throw new Error('変換対象は文字列である必要があります');\n  if (!str) throw new Error('変換対象の文字列が空です');\n  const hyphenProcessed = str.replace(/[－‐‑–—−ー―]/g, '-');\n  try {\n    const halfWidthKana = toHalfWidthKana(hyphenProcessed, false);\n    let errorChar = null;\n    const singleByteCharacters = [...halfWidthKana]\n      .map((char) => {\n        const code = char.charCodeAt(0);\n        // 半角英数字・記号・スペース・カナ以外は変換不能とみなす\n        if (\n          code >= 0xff01 &&\n          code <= 0xff5e // 全角記号・英数字\n        ) {\n          return String.fromCodePoint(code - 0xfee0);\n        }\n        if (char === '\\u3000') return ' '; // 全角スペースを半角に\n        // 変換後が全角カナ・ひらがな・漢字・その他全角文字の場合はエラーまたはそのまま\n        if (\n          (code >= 0x4e00 && code <= 0x9fff) || // 漢字\n          (code >= 0x3040 && code <= 0x309f) || // ひらがな\n          (code >= 0x30a0 && code <= 0x30ff) || // カタカナ\n          (code >= 0xff00 && code <= 0xffef) // その他全角\n        ) {\n          if (throwOnError) errorChar = char;\n          // throwOnError=falseならそのまま返す\n        }\n        return char;\n      })\n      .join('');\n    if (errorChar) throw new Error(`変換不能な文字が含まれています: ${errorChar}`);\n    return singleByteCharacters;\n  } catch (error) {\n    throw new Error(error.message);\n  }\n};\n\n/**\n * メールアドレスの表記を半角文字に変換し、RFC 5322に基づいた形式であるかを判定し、正しくない場合は例外を投げる関数\n * @param {string} emailAddress\n * @returns {string} 正常な場合は変換済みメールアドレス\n * @throws {Error} 不正な場合は例外\n */\nconst assertEmailAddress = (emailAddress = '') => {\n  // 簡易的なRFC5322準拠の正規表現（一般的な用途で十分）\n  const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n  if (!_ch_checkString(emailAddress)) throw new Error('メールアドレスは文字列である必要があります');\n  if (!emailAddress) throw new Error('メールアドレスが空です');\n  const trimmed = emailAddress.trim();\n  try {\n    const singleByteCharacters = toHalfWidth(trimmed);\n    if (/\\.\\.|^\\.|\\.@|@\\.|\\.$/.test(singleByteCharacters))\n      throw new Error('メールアドレスは連続ドットや@直前・直後のドットを含めることはできません');\n    if (!emailPattern.test(singleByteCharacters))\n      throw new Error('メールアドレスの形式が正しくありません');\n    return singleByteCharacters;\n  } catch (error) {\n    throw new Error('`メールアドレスの形式が正しくありません: ${error.message}`');\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/issiki_sigeo/Library/CloudStorage/OneDrive-公益社団法人神奈川県社会福祉士会/ドキュメント/kintone/アプリ開発/my-first-static-web-app/src/date-utils.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'lastUnit' is assigned a value but never used.","line":46,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":46,"endColumn":15},{"ruleId":"no-unused-vars","severity":1,"message":"'eraInitials' is assigned a value but never used.","line":83,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":83,"endColumn":22,"suggestions":[{"messageId":"removeVar","data":{"varName":"eraInitials"},"fix":{"range":[2352,2412],"text":""},"desc":"Remove unused variable 'eraInitials'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'eraNames' is assigned a value but never used.","line":84,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":84,"endColumn":19,"suggestions":[{"messageId":"removeVar","data":{"varName":"eraNames"},"fix":{"range":[2417,2472],"text":""},"desc":"Remove unused variable 'eraNames'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'convertToYear' is assigned a value but never used.","line":201,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":201,"endColumn":20,"suggestions":[{"messageId":"removeVar","data":{"varName":"convertToYear"},"fix":{"range":[6537,10604],"text":""},"desc":"Remove unused variable 'convertToYear'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":215,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":215,"endColumn":15},{"ruleId":"no-unused-vars","severity":1,"message":"'e2' is defined but never used.","line":222,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":222,"endColumn":18},{"ruleId":"no-unused-vars","severity":1,"message":"'e3' is defined but never used.","line":227,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":227,"endColumn":20},{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":303,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":303,"endColumn":15},{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":306,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":306,"endColumn":15},{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":309,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":309,"endColumn":15},{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":312,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":312,"endColumn":15},{"ruleId":"no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":315,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":315,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** 日付処理に関する処理をまとめたJavaScriptの関数群です。\n * @author Shigeo Isshiki <issiki@kacsw.or.jp>\n * @version 1.0.0\n */\n// 関数命名ルール: 外部に見せる関数名はそのまま、内部で使用する関数名は(_du_)で始める\n'use strict';\n//　ライブラリ内の共通定数・変換テーブル定義部\n// 西暦から元号（和暦）への変換ユーティリティ\nconst _DU_ERAS = [\n  { name: '令和', initial: 'R', number: 5, start: new Date('2019-05-01') },\n  { name: '平成', initial: 'H', number: 4, start: new Date('1989-01-08') },\n  { name: '昭和', initial: 'S', number: 3, start: new Date('1926-12-25') },\n  { name: '大正', initial: 'T', number: 2, start: new Date('1912-07-30') },\n  { name: '明治', initial: 'M', number: 1, start: new Date('1868-01-25') },\n];\n// 漢数字→アラビア数字変換テーブル\nconst _DU_KANJI_NUM = {\n  〇: 0,\n  一: 1,\n  二: 2,\n  三: 3,\n  四: 4,\n  五: 5,\n  六: 6,\n  七: 7,\n  八: 8,\n  九: 9,\n  十: 10,\n  百: 100,\n  千: 1000,\n};\n\n//　ライブラリ内の共通関数定義部\n// 漢数字→アラビア数字変換関数（1～3999程度まで対応）\nconst _du_kanjiToNumber = (kanji) => {\n  if (kanji === '元') return 1;\n  let num = 0,\n    tmp = 0,\n    lastUnit = 1;\n  for (let i = 0; i < kanji.length; i++) {\n    const c = kanji[i];\n    if (_DU_KANJI_NUM[c] >= 10) {\n      if (tmp === 0) tmp = 1;\n      num += tmp * _DU_KANJI_NUM[c];\n      tmp = 0;\n      lastUnit = _DU_KANJI_NUM[c];\n    } else if (_DU_KANJI_NUM[c] >= 0) {\n      tmp = tmp * 10 + _DU_KANJI_NUM[c];\n    }\n  }\n  num += tmp;\n  return num;\n};\n\n//　ライブラリ本体部\n/**\n * 和暦・西暦表記（文字列）から西暦のDate型（年月日）に変換する\n * @param {string|Date} date 例: \"令和元年5月1日\", \"平成元年1月8日\", \"2025-10-14\", Date型\n * @returns {Date} 西暦のDate型\n * @throws {Error} 不正な形式の場合\n */\nconst convertToSeireki = (date) => {\n  const formatDate = (d) => {\n    const yyyy = d.getFullYear();\n    const mm = String(d.getMonth() + 1).padStart(2, '0');\n    const dd = String(d.getDate()).padStart(2, '0');\n    return `${yyyy}-${mm}-${dd}`;\n  };\n  if (date instanceof Date) {\n    if (isNaN(date.getTime())) throw new Error('不正な日付です');\n    return formatDate(date);\n  }\n  if (typeof date === 'string') {\n    // 前処理: 全角数字・英字→半角、漢数字→半角アラビア数字、元号漢字→イニシャル、区切りをYYYY-MM-DDに統一\n    const toHankaku = (s) =>\n      s.replace(/[０-９]/g, (c) => String.fromCharCode(c.charCodeAt(0) - 0xfee0));\n    const toHankakuAlpha = (s) =>\n      s.replace(/[Ａ-Ｚａ-ｚ]/g, (c) => String.fromCharCode(c.charCodeAt(0) - 0xfee0));\n    // 漢数字→半角アラビア数字（1～3999程度まで対応）\n    const kanjiNumReg = /[元一二三四五六七八九十百千〇]+/g;\n    const kanjiToNumStr = (s) => s.replace(kanjiNumReg, (m) => _du_kanjiToNumber(m));\n    // 元号漢字→イニシャル\n    const eraInitials = _DU_ERAS.map((e) => e.initial).join('');\n    const eraNames = _DU_ERAS.map((e) => e.name).join('|');\n    const kanjiToInitial = (s) => {\n      let result = s;\n      _DU_ERAS.forEach((e) => {\n        result = result.replace(new RegExp(e.name, 'g'), e.initial);\n      });\n      return result;\n    };\n    // 区切りをYYYY-MM-DDに統一\n    const normalizeDateSeparator = (s) => s.replace(/年|\\/|\\.|\\s|月/g, '-').replace(/日/g, '');\n    let normalized = typeof date === 'string' ? date : '';\n    normalized = toHankakuAlpha(toHankaku(normalized));\n    normalized = kanjiToNumStr(normalized);\n    normalized = kanjiToInitial(normalized);\n    normalized = normalizeDateSeparator(normalized);\n    if (typeof normalized !== 'string') normalized = String(normalized ?? '');\n    normalized = normalized.replace(/^-+|-+$/g, ''); // 先頭・末尾の余分な区切りを除去\n    // 区切りで分割し、和暦パターン判定\n    const parts = normalized.split('-').filter(Boolean);\n    // 例: [\"H\", \"1\", \"1\", \"8\"] or [\"H\", \"1\", \"8\"]\n    if (parts.length >= 3 && parts.length <= 4) {\n      let initial = parts[0];\n      let yearStr = '';\n      // initialが2文字以上の場合（例: H1, R7, H13）\n      if (initial.length > 1) {\n        yearStr = initial.slice(1);\n        initial = initial[0];\n      }\n      // 大文字・小文字両方対応\n      let era = _DU_ERAS.find((e) => e.initial.toUpperCase() === initial.toUpperCase());\n      if (era) {\n        let yearNum, monthNum, dayNum;\n        if (yearStr) {\n          // initial+年パターン\n          yearNum = parseInt(yearStr, 10);\n          monthNum = parseInt(parts[1], 10);\n          dayNum = parseInt(parts[2], 10);\n        } else {\n          // initial, 年, 月, 日パターン\n          yearNum = parseInt(parts[1], 10);\n          monthNum = parseInt(parts[2], 10);\n          dayNum = parts.length === 4 ? parseInt(parts[3], 10) : 1;\n        }\n        if (yearNum === 0) yearNum = 1;\n        if (monthNum === 0) monthNum = 1;\n        if (dayNum === 0) dayNum = 1;\n        const year = era.start.getFullYear() + yearNum - 1;\n        const resultDate = new Date(year, monthNum - 1, dayNum);\n        return formatDate(resultDate);\n      }\n    }\n    // 西暦（YYYY-MM-DD, YYYY/MM/DD, YYYY年MM月DD日）\n    const ymdMatch = normalized.match(/^(\\d{4})-(\\d{1,2})-(\\d{1,2})$/);\n    if (ymdMatch) {\n      const y = parseInt(ymdMatch[1], 10);\n      const m = parseInt(ymdMatch[2], 10);\n      const d0 = parseInt(ymdMatch[3], 10);\n      // 日付部分が1～31以外はエラー\n      if (d0 < 1 || d0 > 31) {\n        throw new Error('存在しない日付です');\n      }\n      const d = new Date(`${y}-${String(m).padStart(2, '0')}-${String(d0).padStart(2, '0')}`);\n      return formatDate(d);\n    }\n  }\n  throw new Error('不正な入力形式です');\n};\n\n/**\n * 日付から元号表記（和暦）に変換し、和暦の年のみ複数形式で返す\n * @param {Date|string} date 日付（Date型または'YYYY-MM-DD'形式の文字列）\n * @returns {object} 戻り値オブジェクトの内容:\n *   - kanji: 元号＋年（例: \"令和7年\"、\"平成元年\"）\n *   - initial: 元号イニシャル＋年（JIS X 0301:2019準拠、例: \"R07\"、\"H01\"、元年は\"01\"）\n *   - initialOnly: 元号イニシャルのみ（例: \"R\"、\"H\"）\n *   - numberOnly: 元号年の2桁（例: \"07\"、\"53\"、元年は\"01\"）\n */\nconst convertToEra = (date) => {\n  // まずconvertToSeirekiで西暦日付（YYYY-MM-DD）に変換\n  let seirekiStr;\n  if (date instanceof Date) {\n    seirekiStr = convertToSeireki(date);\n  } else if (typeof date === 'string') {\n    seirekiStr = convertToSeireki(date);\n  } else {\n    throw new Error('日付不正: Date型または文字列で指定してください');\n  }\n  // 変換した値をDate型に\n  const d = new Date(seirekiStr);\n  if (isNaN(d.getTime())) {\n    throw new Error('日付不正: 有効な日付形式を指定してください');\n  }\n  for (const era of _DU_ERAS) {\n    if (d >= era.start) {\n      // 年号の開始年のみで計算（+1）\n      const eraYear = d.getFullYear() - era.start.getFullYear() + 1;\n      const kanji = `${era.name}${eraYear === 1 ? '元' : eraYear}年`;\n      const initial = `${era.initial}${eraYear === 1 ? '01' : String(eraYear).padStart(2, '0')}`;\n      const initialOnly = `${era.initial}`;\n      const numberOnly = `${eraYear === 1 ? '01' : String(eraYear).padStart(2, '0')}`;\n      return {\n        kanji,\n        initial,\n        initialOnly,\n        numberOnly,\n      };\n    }\n  }\n  throw new Error('明治以前の日付は対応していません');\n};\n\n/**\n * 様々な日付入力から西暦の年（数値）だけを取り出す\n * @param {string|Date} date 例: \"令和元年5月1日\", \"R1/5/1\", \"2019-05-01\", \"2025\", Date\n * @returns {number} 西暦年（例: 2019）\n * @throws {Error} 解釈できない場合\n */\nconst convertToYear = (date) => {\n  // 1) Dateオブジェクトならそのまま\n  if (date instanceof Date) {\n    if (isNaN(date.getTime())) throw new Error('不正な日付です');\n    return date.getFullYear();\n  }\n\n  // 2) まず既存のconvertToSeirekiでフル日付として解釈を試みる\n  if (typeof date === 'string') {\n    // まず convertToSeireki でフル日付として解釈を試みる\n    try {\n      const seireki = convertToSeireki(date); // 'YYYY-MM-DD' 形式\n      const y = parseInt(seireki.slice(0, 4), 10);\n      if (!isNaN(y)) return y;\n    } catch (e) {\n      // フル日付として解釈できないケースは、年のみ／年+月のみ等の可能性があるため\n      // '1日' や '1月1日' を付けて再試行してみる（例: '昭和八十年' -> '昭和八十年1月1日'）\n      try {\n        const seireki = convertToSeireki(String(date) + '1日');\n        const y = parseInt(seireki.slice(0, 4), 10);\n        if (!isNaN(y)) return y;\n      } catch (e2) {\n        try {\n          const seireki = convertToSeireki(String(date) + '1月1日');\n          const y = parseInt(seireki.slice(0, 4), 10);\n          if (!isNaN(y)) return y;\n        } catch (e3) {\n          // どれもダメなら下のフォールバック処理へ\n        }\n      }\n    }\n\n    // フォールバック: 元号のみ / 年のみ / 全角数字や漢数字を含むケースを処理\n    const toHankaku = (s) =>\n      s.replace(/[０-９]/g, (c) => String.fromCharCode(c.charCodeAt(0) - 0xfee0));\n    const toHankakuAlpha = (s) =>\n      s.replace(/[Ａ-Ｚａ-ｚ]/g, (c) => String.fromCharCode(c.charCodeAt(0) - 0xfee0));\n    const kanjiNumReg = /[元一二三四五六七八九十百千〇]+/g;\n    const kanjiToNumStr = (s) => s.replace(kanjiNumReg, (m) => _du_kanjiToNumber(m));\n    const kanjiToInitial = (s) => {\n      let result = s;\n      _DU_ERAS.forEach((e) => {\n        result = result.replace(new RegExp(e.name, 'g'), e.initial);\n      });\n      return result;\n    };\n\n    let normalized = toHankakuAlpha(toHankaku(String(date)));\n    normalized = kanjiToNumStr(normalized);\n    normalized = kanjiToInitial(normalized);\n    // 年月日や区切りを '-' に統一（ただし日付の存在は問いません）\n    normalized = normalized.replace(/年|日|\\/|\\.|\\s|月|\\//g, '-');\n    normalized = normalized.replace(/^-+|-+$/g, '');\n\n    // 4桁の西暦年単独\n    let m = normalized.match(/^(\\d{4})$/);\n    if (m) return parseInt(m[1], 10);\n    // 文字列先頭に4桁西暦がある場合（例: '2025-5' や '2025/05/01' の正規化不足ケース）\n    m = normalized.match(/^(\\d{4})(?:-|$)/);\n    if (m) return parseInt(m[1], 10);\n\n    // 元号（イニシャル）パターン: 先頭がイニシャルのとき 年が続くか、次のパートに年がある\n    // 例: 'R1', 'R01', 'R-1-5-1', 'R-1' , 'R1-5-1'\n    const parts = normalized.split('-').filter(Boolean);\n    if (parts.length > 0) {\n      // 先頭がイニシャル単体もしくはイニシャル＋数字のパターン\n      const head = parts[0];\n      let initial = null,\n        yearNum = null;\n      if (/^[A-Za-z]\\d*$/.test(head)) {\n        // 'R1' や 'R01' のような形\n        initial = head[0];\n        const rest = head.slice(1);\n        if (rest) yearNum = parseInt(rest, 10);\n      } else if (/^[A-Za-z]$/.test(head) && parts.length >= 2 && /^\\d+$/.test(parts[1])) {\n        // 'R' '-' '1' のように分かれている場合\n        initial = head[0];\n        yearNum = parseInt(parts[1], 10);\n      }\n\n      if (initial) {\n        if (!yearNum) {\n          // 年が指定されていない（例: 'R' 単体）は解釈できない\n          throw new Error('元号のみの指定は年が不明です');\n        }\n        if (yearNum === 0) yearNum = 1; // 0 が来たら元年扱い\n        const era = _DU_ERAS.find((e) => e.initial.toUpperCase() === initial.toUpperCase());\n        if (era) {\n          return era.start.getFullYear() + yearNum - 1;\n        }\n      }\n    }\n\n    // 最後の手段: 文字列中の4桁を探す\n    m = normalized.match(/(\\d{4})/);\n    if (m) return parseInt(m[1], 10);\n  }\n\n  // 公開: kintone 等から参照されることがあるユーティリティをグローバルに露出\n  if (typeof window !== 'undefined') {\n    try {\n      window.lastUnit = typeof lastUnit !== 'undefined' ? lastUnit : undefined;\n    } catch (e) {}\n    try {\n      window.eraInitials = typeof eraInitials !== 'undefined' ? eraInitials : undefined;\n    } catch (e) {}\n    try {\n      window.eraNames = typeof eraNames !== 'undefined' ? eraNames : undefined;\n    } catch (e) {}\n    try {\n      window.convertToEra = typeof convertToEra !== 'undefined' ? convertToEra : undefined;\n    } catch (e) {}\n    try {\n      window.convertToYear = typeof convertToYear !== 'undefined' ? convertToYear : undefined;\n    } catch (e) {}\n  }\n\n  throw new Error('不正な入力形式です');\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/issiki_sigeo/Library/CloudStorage/OneDrive-公益社団法人神奈川県社会福祉士会/ドキュメント/kintone/アプリ開発/my-first-static-web-app/src/date_handling.js","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Delete `⏎`","line":534,"column":1,"nodeType":null,"messageId":"delete","endLine":535,"endColumn":1,"fix":{"range":[16682,16683],"text":""}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/** 日付処理をまとめたJavaScriptの関数群です。\n * @author Shigeo Isshiki <issiki@kacsw.or.jp>\n * @version 1.0.0\n */\n// 関数命名ルール: 外部に見せる関数名はそのまま、内部で使用する関数名は(_dh_)で始める\n// 元号改元時の対応: ERAS関数を定義しているところに新元号を追加してください。maxは終了する年がわからないため99と設定します。\n'use strict';\n/** 文字列が文字列型であることを確認する関数\n * @param {*} str - 確認する文字列\n * @returns {*} 特に何も返さない\n */\nconst _dh_assertString = (str) => {\n  if (typeof str !== 'string' || str === null || str === undefined)\n    throw new Error(`[${str}] must be a string`);\n};\n/**\n * 文字列が文字列型であることを確認する関数\n * @param {*} str - 確認する文字列\n * @returns {boolean} 文字列である = true、文字でない = false\n */\nconst _dh_checkString = (str) => {\n  return typeof str === 'string' && str !== null && str !== undefined;\n};\n/**\n * 月をDate関数にあわせて減算する（1月〜12月が0〜11で表されるため）\n * @param {number} month - 月を表す数字\n * @returns {number} Date関数にあわせた月の数値\n */\nconst _dh_newDateMonth = (month) => month - 1;\n/**\n * 元号データを一元管理する配列\n * 新元号追加時はこの配列に1行追加するだけでOK\n * ERAS配列のstartの月は「1始まり」で記述してください（例: 10月→10）。内部で0始まりに変換します。\n * @constant {Array} ERAS - 元号データを一元管理する配列\n * @property {string} name - 元号名\n * @property {string} initial - 元号イニシャル（大文字の半角英字1文字）\n * @property {Date} start - 元号の開始日を表すDateオブジェクト\n * @property {number} max - その元号で表せる和暦年の最大値\n */\nconst ERAS = [\n  {\n    name: '明治',\n    initial: 'M',\n    start: new Date(1868, _dh_newDateMonth(10), 23),\n    max: 45,\n  },\n  {\n    name: '大正',\n    initial: 'T',\n    start: new Date(1912, _dh_newDateMonth(7), 30),\n    max: 15,\n  },\n  {\n    name: '昭和',\n    initial: 'S',\n    start: new Date(1926, _dh_newDateMonth(12), 25),\n    max: 64,\n  },\n  {\n    name: '平成',\n    initial: 'H',\n    start: new Date(1989, _dh_newDateMonth(1), 8),\n    max: 31,\n  },\n  {\n    name: '令和',\n    initial: 'R',\n    start: new Date(2019, _dh_newDateMonth(5), 1),\n    max: 99,\n  }, // 令和は仮に99年まで対応\n];\n// 元号名・イニシャルのリストを自動生成\n/**\n * 元号名のリストを表す配列\n * @constant {Array} _dh_eraNames - 元号名のリストを表す配列\n */\nconst _dh_eraNames = ERAS.map((e) => e.name);\n/**\n * 元号イニシャルのリストを表す配列\n * @constant {Array} _dh_eraInitials - 元号イニシャルのリストを表す配列\n */\nconst _dh_eraInitials = ERAS.map((e) => e.initial);\n/**\n * 和暦の年を表す正規表現パターン\n * @constant {string} _dh_warekiYearPattern - 和暦の年を表す正規表現パターン\n */\nconst _dh_warekiYearPattern = '(元\\\\d{1,2}|\\\\d{1,2})';\n/**\n * 入力文字をすべて大文字の半角文字に変換する関数\n * @param {string} str\n * @returns {string} 大文字の半角文字に変換後の文字列\n */\nconst _dh_normalizeString = (str) => {\n  if (!_dh_checkString(str)) throw new Error('入力値が文字列ではありません');\n  return str.normalize('NFKC').toUpperCase();\n};\n/**\n * 日付形式の正規表現パターンを生成する関数\n * @param {Array<string>} separators - 区切り文字の配列\n * @param {boolean} includeDay - 日付を含めるかどうか\n * @param {boolean} includeInitials - 和暦イニシャルを含めるか\n * @returns {Array<RegExp>} - 正規表現の配列\n */\nconst _dh_createDatePattern = (separators = [''], includeDay = true, includeInitials = true) => {\n  if (!Array.isArray(separators) || separators.length === 0) separators = [''];\n  // 区切り文字を正規表現クラスにまとめる\n  const sepClass =\n    separators.length > 1\n      ? `[${separators.map((s) => s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')).join('')}]`\n      : separators[0]\n        ? separators[0].replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n        : '';\n  const year = '\\\\d{4}';\n  const month = '\\\\d{1,2}';\n  const day = includeDay ? '\\\\d{1,2}' : '';\n  const warekiYear = _dh_warekiYearPattern;\n  const patterns = [];\n  // 西暦\n  patterns.push(new RegExp(`^${year}年${month}月${includeDay ? `${day}日` : ''}$`));\n  if (sepClass) {\n    patterns.push(\n      new RegExp(`^${year}${sepClass}${month}${includeDay ? `${sepClass}${day}` : ''}$`)\n    );\n  }\n  // 和暦\n  [..._dh_eraNames, ...(includeInitials ? _dh_eraInitials : [])].forEach((era) => {\n    patterns.push(new RegExp(`^${era}${warekiYear}年${month}月${includeDay ? `${day}日` : ''}$`));\n    if (sepClass) {\n      patterns.push(\n        new RegExp(\n          `^${era}${warekiYear}${sepClass}${month}${includeDay ? `${sepClass}${day}` : ''}$`\n        )\n      );\n    }\n  });\n  return patterns;\n};\n/**\n * 日付の区分けに使う記号をまとめた配列\n * @constant {array} _dh_commonSeparators - 日付の区分けに使う記号を表す配列\n */\nconst _dh_commonSeparators = [\n  '/', // 半角スラッシュ\n  '-', // 半角ハイフン（U+002D）\n  '.', // 半角ドット\n  '／', // 全角スラッシュ（U+FF0F）\n  '‐', // 全角ハイフン（U+2010）\n  '－', // 全角ハイフン（U+FF0D）\n  'ー', // 全角長音符（U+30FC）※誤入力対策\n  '−', // 全角マイナス記号（U+2212）\n  '．', // 全角ドット（U+FF0E）\n];\n/**\n * 日付形式の正規表現パターンをまとめたオブジェクト\n * @constant {object} _dh_patterns - 日付形式の正規表現パターン\n * @property {Array} ymdKanji - 「YYYY年MM月DD日」形式の正規表現\n * @property {Array} ymdSlash - 「YYYY/MM/DD」形式の正規表現\n * @property {Array} ymdCompact - 「YYYYMMDD」形式の正規表現\n * @property {Array} ymKanji - 「YYYY年MM月」形式の正規表現\n * @property {Array} ymSlash - 「YYYY/MM」形式の正規表現\n * @property {Array} ymCompact - 「YYYYMM」形式の正規表現\n * @property {Array} yKanji - 「YYYY年」形式の正規表現\n * @property {Array} yOnly - 「YYYY」形式の正規表現\n */\nconst _dh_patterns = {\n  ymdKanji: _dh_createDatePattern('', true), // 「YYYY年MM月DD日」形式の正規表現\n  ymdSlash: _dh_createDatePattern(_dh_commonSeparators, true), // 「YYYY/MM/DD」形式の正規表現\n  ymdCompact: [\n    // 「YYYYMMDD」形式の正規表現\n    /^\\d{8}$/,\n    /^.{1,2}元\\d{4}$/,\n    /^.{1,2}\\d{5,6}$/,\n  ],\n  ymKanji: _dh_createDatePattern('', false), // 「YYYY年MM月」形式の正規表現\n  ymSlash: _dh_createDatePattern(_dh_commonSeparators, false), // 「YYYY/MM」形式の正規表現\n  ymCompact: [\n    // 「YYYYMM」形式の正規表現\n    /^\\d{6}$/,\n    /^.{1,2}元\\d{2}$/,\n    /^.{1,2}\\d{3,4}$/,\n  ],\n  yKanji: [\n    // 「YYYY年」形式の正規表現\n    /^\\d{4}年$/,\n    /^.{1,2}元年$/,\n    /^.{1,2}\\d{1,2}年$/,\n  ],\n  yOnly: [\n    // 「YYYY」形式の正規表現\n    /^\\d{4}$/,\n    /^.{1,2}元$/,\n    /^.{1,2}\\d{1,2}$/,\n  ],\n};\n/**\n * 年月日が有効な日付かどうかを厳密に判定する関数（うるう年対応）\n * @param {number} year 年\n * @param {number} month 月\n * @param {number} day 日\n * @returns {boolean}\n */\nconst _dh_isValidDate = (year, month, day) => {\n  if (!Number.isInteger(year) || !Number.isInteger(month) || !Number.isInteger(day)) return false;\n  if (month < 1 || month > 12) return false;\n  if (day < 1) return false;\n  const daysInMonth = [\n    31,\n    year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) ? 29 : 28,\n    31,\n    30,\n    31,\n    30,\n    31,\n    31,\n    30,\n    31,\n    30,\n    31,\n  ];\n  if (day > daysInMonth[_dh_newDateMonth(month)]) return false;\n  return true;\n};\n/**\n * 日付文字列を年月日の配列形式に分割する関数\n * @param {string} date_str 分割対象の日付文字列\n * @returns {object} 年月日の配列形式に分割したオブジェクト\n * @property {string} year - 年の文字列（分割できなかった場合は空白を返す）\n * @property {string} month - 月の文字列（分割できなかった場合は空白を返す）\n * @property {string} day - 日の文字列（分割できなかった場合は空白を返す）\n */\nconst _dh_date_string_split = (date_str) => {\n  _dh_assertString(date_str);\n  if (!date_str) throw new Error('日付文字列が空です');\n  // ERAS配列からeraPatternsを自動生成\n  const _dh_generateEraPatterns = () => {\n    const patterns = {};\n    ERAS.forEach((e) => {\n      // 全角・半角イニシャルも考慮\n      const ascii = e.initial;\n      const lower = ascii.toLowerCase();\n      const zenkaku = String.fromCharCode(ascii.charCodeAt(0) + 0xfee0);\n      const zenkakuLower = String.fromCharCode(lower.charCodeAt(0) + 0xfee0);\n      const initials = [ascii, lower, zenkaku, zenkakuLower].join('');\n      patterns[e.name] = [\n        new RegExp(`^${e.name}元$`),\n        new RegExp(`^${e.name}\\\\d{1,2}$`),\n        new RegExp(`^[${initials}]元$`),\n        new RegExp(`^[${initials}]\\\\d{1,2}$`),\n      ];\n    });\n    return patterns;\n  };\n  const eraPatterns = _dh_generateEraPatterns();\n  let date_str_split = {\n    year: '',\n    month: '',\n    day: '',\n  };\n  const detectDateType = (str) => {\n    for (const [type, regexList] of Object.entries(_dh_patterns)) {\n      if (regexList.some((regex) => regex.test(str))) {\n        return type;\n      }\n    }\n    return '';\n  };\n  const _dh_splitDateString = (type, str) => {\n    switch (type) {\n      case 'ymdKanji':\n      case 'ymKanji':\n      case 'yKanji':\n        return str.split(/[年月日]/).filter(Boolean);\n      case 'ymdSlash':\n      case 'ymSlash':\n      case 'yOnly':\n        return str.split(/[\\/\\-\\.\\／‐．−ー－]/);\n      case 'ymdCompact':\n        return [str.slice(0, 4), str.slice(4, 6), str.slice(6, 8)];\n      case 'ymCompact':\n        return [str.slice(0, 4), str.slice(4, 6)];\n      default:\n        return [];\n    }\n  };\n  const convert_to_single_byte_numbers = (str = '') => {\n    if (!str) return '';\n    const convertKanjiNumerals = (str = '') => {\n      const parseKanjiNumber = (kanji) => {\n        const digits = {\n          〇: 0,\n          一: 1,\n          二: 2,\n          三: 3,\n          四: 4,\n          五: 5,\n          六: 6,\n          七: 7,\n          八: 8,\n          九: 9,\n        };\n        const multipliers = { 十: 10, 百: 100, 千: 1000, 万: 10000 };\n        let total = 0;\n        let current = 0;\n        let temp = 0;\n        for (let c = 0; c < kanji.length; c++) {\n          const char = kanji[c];\n          if (char in digits) {\n            current = digits[char];\n          } else if (char in multipliers) {\n            if (current === 0) current = 1;\n            temp += current * multipliers[char];\n            current = 0;\n          }\n        }\n        total = temp + current;\n        return total;\n      };\n      return str.replace(/[〇一二三四五六七八九十百千]+/g, (match) => parseKanjiNumber(match));\n    };\n    const convertFullWidthDigits = (str = '') => {\n      return str.replace(/[０-９]/g, (char) => String.fromCharCode(char.charCodeAt(0) - 0xfee0));\n    };\n    str = convertKanjiNumerals(str);\n    str = convertFullWidthDigits(str);\n    return str;\n  };\n  const convertWarekiToSeireki = (eraName, eraYear, month, day) => {\n    // eraNameは元号名またはイニシャルどちらでもOK\n    const era = ERAS.find((e) => e.name === eraName || e.initial === eraName);\n    if (!era) throw new Error('不明な元号です');\n    if (!Number.isInteger(eraYear) || eraYear < 1 || eraYear > era.max)\n      throw new Error('和暦年の値が不正です');\n    if (month < 1 || month > 12) throw new Error('月の値が不正です');\n    if (day < 1 || day > 31) throw new Error('日の値が不正です');\n    const convertedYear = era.start.getFullYear() + (eraYear - 1);\n    if (!_dh_isValidDate(convertedYear, month, day)) throw new Error('日付が不正です');\n    const convertedDate = new Date(convertedYear, _dh_newDateMonth(month), day);\n    if (convertedDate < era.start) throw new Error('和暦の開始日より前の日付です');\n    return convertedYear;\n  };\n  const date_str_ns = _dh_normalizeString(date_str);\n  const date_str_sbn = convert_to_single_byte_numbers(date_str_ns);\n  const date_type = detectDateType(date_str_sbn);\n  if (/^\\d{8}$/.test(date_str_sbn)) {\n    // YYYYMMDD形式\n    return {\n      year: date_str_sbn.slice(0, 4),\n      month: date_str_sbn.slice(4, 6),\n      day: date_str_sbn.slice(6, 8),\n    };\n  }\n  const date_str_sbn_split = _dh_splitDateString(date_type, date_str_sbn);\n  let yearnumber = 0;\n  if (date_str_sbn_split.length >= 1 && date_str_sbn_split[0]) {\n    // 年の文字列がある場合\n    let era_type = 0;\n    for (const [eraName, patterns] of Object.entries(eraPatterns)) {\n      if (patterns.some((pat) => pat.test(date_str_sbn_split[0]))) {\n        era_type = _dh_eraNames.indexOf(eraName) + 1;\n        break;\n      }\n    }\n    let yearchar = '';\n    if (era_type > 0) {\n      // 日付形式の文字列が和暦表記の場合\n      // ERAS配列から元号名・イニシャル（全角・半角）をすべて削除\n      let tmp = date_str_sbn_split[0];\n      ERAS.forEach((e) => {\n        // 元号名\n        tmp = tmp.replace(new RegExp(e.name, 'g'), '');\n        // イニシャル（半角大・小、全角大・小）\n        const ascii = e.initial;\n        const lower = ascii.toLowerCase();\n        const zenkaku = String.fromCharCode(ascii.charCodeAt(0) + 0xfee0);\n        const zenkakuLower = String.fromCharCode(lower.charCodeAt(0) + 0xfee0);\n        [ascii, lower, zenkaku, zenkakuLower].forEach((init) => {\n          tmp = tmp.replace(new RegExp(init, 'g'), '');\n        });\n      });\n      yearchar = tmp;\n    } else {\n      // 日付形式の文字列が西暦表記の場合\n      yearchar = date_str_sbn_split[0];\n    }\n    if (yearchar === '元') {\n      // 和暦の元年表記の場合\n      yearchar = '1';\n    }\n    yearnumber = Number(yearchar);\n    if (era_type > 0) {\n      const eraName = _dh_eraNames[era_type - 1];\n      const month =\n        date_str_sbn_split.length >= 2 && date_str_sbn_split[1] ? Number(date_str_sbn_split[1]) : 1;\n      const day =\n        date_str_sbn_split.length >= 3 && date_str_sbn_split[2] ? Number(date_str_sbn_split[2]) : 1;\n      const convertedYear = convertWarekiToSeireki(eraName, yearnumber, month, day);\n      if (convertedYear > 0) {\n        yearnumber = convertedYear;\n      } else {\n        yearnumber = 0;\n      }\n    }\n    if (yearnumber >= 1) {\n      // 年の数値が1以上の場合\n      date_str_split.year = String(yearnumber);\n    }\n  }\n  if (date_str_sbn_split.length >= 2 && date_str_sbn_split[1]) {\n    // 月の文字列がある場合\n    if (Number(date_str_sbn_split[1]) >= 1 && Number(date_str_sbn_split[1]) <= 12) {\n      // 月表記が1月～12月になっている場合\n      date_str_split.month = ('0' + date_str_sbn_split[1]).slice(-2);\n    } else {\n      // 月表記が1月～12月になっていない場合\n      date_str_split.month = '';\n    }\n  }\n  if (date_str_sbn_split.length >= 3 && date_str_sbn_split[2]) {\n    // 日の文字列がある場合\n    if (\n      _dh_isValidDate(\n        Number(yearnumber),\n        Number(date_str_sbn_split[1]),\n        Number(date_str_sbn_split[2])\n      )\n    ) {\n      date_str_split.day = ('0' + date_str_sbn_split[2]).slice(-2);\n    }\n  }\n  if (!date_str_split.year) throw new Error('年の抽出に失敗しました');\n  return date_str_split;\n};\n\n/**\n * 西暦和暦を問わず日付文字列をISO 8601拡張形式の西暦表記（YYYY-MM-DD）に変換する関数\n * @param {string} date_str 変換対象の日付文字列\n * @returns {string} ISO 8601拡張形式の西暦表記（YYYY-MM-DD）の文字列\n * @throws 変換できなかった場合は例外を投げる\n */\nconst convert_to_anno_domini = (date_str) => {\n  if (!_dh_checkString(date_str)) throw new Error('日付文字列が不正です');\n  if (!date_str) throw new Error('日付文字列が空です');\n  const date_str_split = _dh_date_string_split(date_str);\n  const year = Number(date_str_split.year);\n  const month = Number(date_str_split.month);\n  const day = Number(date_str_split.day);\n  if (year && month && day && _dh_isValidDate(year, month, day)) {\n    return `${year}-${('0' + month).slice(-2)}-${('0' + day).slice(-2)}`;\n  }\n  throw new Error('日付の変換に失敗しました');\n};\n\n/**\n * 西暦和暦を問わず日付文字列を、西暦の「YYYY年MM月」と「YYYY/MM」の２形式に変換する関数\n * @param {string} date_str 変換対象の日付文字列\n * @returns {object} 西暦の２形式に変換したオブジェクト\n * @property {string} char - 「YYYY年MM月」形式の年月表記\n * @property {string} jacsw - 「YYYY/MM」形式の年月表記\n * @throws 変換できなかった場合は例外を投げる\n */\nconst convert_to_year_month = (date_str) => {\n  if (!_dh_checkString(date_str)) throw new Error('日付文字列が不正です');\n  if (!date_str) throw new Error('日付文字列が空です');\n  const date_str_split = _dh_date_string_split(date_str);\n  const year = Number(date_str_split.year);\n  const month = Number(date_str_split.month);\n  if (year && month && _dh_isValidDate(year, month, 1)) {\n    return {\n      char: `${year}年${('0' + month).slice(-2)}月`,\n      jacsw: `${year}/${('0' + month).slice(-2)}`,\n    };\n  }\n  throw new Error('年月の変換に失敗しました');\n};\n\n/**\n * 西暦和暦を問わず日付文字列を西暦の年形式に変換する関数\n * @param {string} date_str 変換対象の日付文字列\n * @returns {string} 西暦の年形式の文字列\n * @throws 変換できなかった場合は例外を投げる\n */\nconst convert_to_year = (date_str) => {\n  if (!_dh_checkString(date_str)) throw new Error('日付文字列が不正です');\n  if (!date_str) throw new Error('日付文字列が空です');\n  const date_str_split = _dh_date_string_split(date_str);\n  const year = Number(date_str_split.year);\n  if (year && _dh_isValidDate(year, 1, 1)) return date_str_split.year;\n  throw new Error('年の変換に失敗しました');\n};\n\n/**\n * 西暦和暦を問わず日付文字列を、和暦の「漢字表記年号EE年」、「英字1文字EE」、「EE」の３形式に変換する関数\n * @param {string} date_str 変換対象の日付文字列\n * @returns {object} 和暦の３形式に変換したオブジェクト\n * @property {string} full_era_year - 「漢字表記年号EE年」形式の和暦表記の文字列\n * @property {string} initial_era_year - 「英字1文字EE」形式の和暦年表記の文字列\n * @property {string} era_year_number - 「EE」形式の和暦年のみ表記の文字列\n * @throws 変換できなかった場合は例外を投げる\n */\nconst convert_to_era_year = (date_str) => {\n  if (!_dh_checkString(date_str)) throw new Error('日付文字列が不正です');\n  if (!date_str) throw new Error('日付文字列が空です');\n  // ERAS配列を利用\n  const getEraFromDate = (date) => {\n    for (let c = ERAS.length - 1; c >= 0; c--) {\n      if (date >= ERAS[c].start) return ERAS[c];\n    }\n    return null;\n  };\n  const date_str_split = _dh_date_string_split(date_str);\n  const year = Number(date_str_split.year);\n  const month = Number(date_str_split.month);\n  const day = Number(date_str_split.day);\n  if (!(year && month && day && _dh_isValidDate(year, month, day)))\n    throw new Error('和暦変換に失敗しました');\n  const date = new Date(year, _dh_newDateMonth(month), day);\n  const era = getEraFromDate(date);\n  if (!era) throw new Error('和暦変換に失敗しました');\n  const eraYear = date.getFullYear() - era.start.getFullYear() + 1;\n  return {\n    full_era_year: `${era.name}${eraYear}年`,\n    initial_era_year: `${era.initial}${eraYear}年`,\n    era_year_number: `${eraYear}`,\n  };\n};\n\n// 公開: kintone から参照されることがある変換関数をグローバルに露出\nif (typeof window !== 'undefined') {\n  window.convert_to_anno_domini = convert_to_anno_domini;\n  window.convert_to_year_month = convert_to_year_month;\n  window.convert_to_year = convert_to_year;\n  window.convert_to_era_year = convert_to_era_year;\n}\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/issiki_sigeo/Library/CloudStorage/OneDrive-公益社団法人神奈川県社会福祉士会/ドキュメント/kintone/アプリ開発/my-first-static-web-app/src/financial_institution_processing.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'_fi_DEPOSIT_TYPE_TOZA' is assigned a value but never used.","line":42,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":42,"endColumn":28,"suggestions":[{"messageId":"removeVar","data":{"varName":"_fi_DEPOSIT_TYPE_TOZA"},"fix":{"range":[1478,1512],"text":""},"desc":"Remove unused variable '_fi_DEPOSIT_TYPE_TOZA'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'_fi_DEPOSIT_TYPE_FUTSU' is assigned a value but never used.","line":43,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":43,"endColumn":29,"suggestions":[{"messageId":"removeVar","data":{"varName":"_fi_DEPOSIT_TYPE_FUTSU"},"fix":{"range":[1513,1548],"text":""},"desc":"Remove unused variable '_fi_DEPOSIT_TYPE_FUTSU'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'convertJapanPostAccount' is assigned a value but never used.","line":1159,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":1159,"endColumn":30,"suggestions":[{"messageId":"removeVar","data":{"varName":"convertJapanPostAccount"},"fix":{"range":[31479,35378],"text":""},"desc":"Remove unused variable 'convertJapanPostAccount'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'isValidTransferDate' is assigned a value but never used.","line":1409,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":1409,"endColumn":26,"suggestions":[{"messageId":"removeVar","data":{"varName":"isValidTransferDate"},"fix":{"range":[39358,41761],"text":""},"desc":"Remove unused variable 'isValidTransferDate'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** 金融機関処理をまとめたJavaScriptの関数群です。\n * @author Shigeo Isshiki <issiki@kacsw.or.jp>\n * @version 1.0.0\n */\n// 関数命名ルール: 外部に見せる関数名はそのまま、内部で使用する関数名は(_fi_)で始める\n/* exported convertAccountHolderKana, getByteLength, sliceByByteLength, _fi_DEPOSIT_TYPE_TOZA, _fi_DEPOSIT_TYPE_FUTSU, convertJapanPostAccount, isValidTransferDate */\n// リソースの読み込み制限を行っている場合は、fetch通信を下記のURLに対して許可する必要があります\n// https://bank.teraren.com\n// https://api.national-holidays.jp\n'use strict';\n// --- 外部APIエンドポイント定数 ---\n/** 銀行APIベースURL @type {string} */\nconst _fi_BANK_API_BASE_URL = 'https://bank.teraren.com';\n/** 祝日APIベースURL @type {string} */\nconst _fi_HOLIDAY_API_BASE_URL = 'https://api.national-holidays.jp';\n/**\n * 金融機関処理用の統一エラークラス\n * @class\n * @extends {Error}\n * @param {string} message エラーメッセージ\n * @param {'logic'|'ajax'|'validation'|'unknown'} [type='unknown'] エラー種別\n * @property {string} name エラー名（NationalHolidayError）\n * @property {'logic'|'ajax'|'validation'|'unknown'} type エラー種別\n * @throws {Error} 継承元Errorの例外\n * @private\n */\nclass _fi_FinancialInstitutionError extends Error {\n  constructor(message, type = 'unknown') {\n    super(message);\n    this.name = 'FinancialInstitutionError';\n    this.type = type;\n  }\n}\n// --- Magic Number 定数 ---\nconst _fi_BANK_CODE_LENGTH = 4;\nconst _fi_BRANCH_CODE_LENGTH = 3;\nconst _fi_ACCOUNT_NUMBER_LENGTH = 7;\nconst _fi_JAPAN_POST_SYMBOL_LENGTH = 5;\nconst _fi_JAPAN_POST_NUMBER_MAX_LENGTH = 8;\nconst _fi_TRANSFER_DATE_MIN_DAYS = 1;\nconst _fi_TRANSFER_DATE_MAX_DAYS = 14;\nconst _fi_DEPOSIT_TYPE_TOZA = '0';\nconst _fi_DEPOSIT_TYPE_FUTSU = '1';\nconst _fi_CUTOFF_HOUR_FOR_NEXT_DAY = 18;\nconst _fi_SUNDAY = 0;\nconst _fi_SATURDAY = 6;\nconst _fi_JANUARY = 0;\nconst _fi_DECEMBER = 11;\nconst _fi_NEW_YEAR_EVE = 31;\nconst _fi_NEW_YEAR_DAYS = [1, 2, 3];\n// --- 変換用定数・マッピング ---\n/** 全角カナ変換マッピング @type {Object} */\nconst _fi_FULL_WIDTH_KANA_LIST = {\n  ｱ: 'ア',\n  ｲ: 'イ',\n  ｳ: 'ウ',\n  ｴ: 'エ',\n  ｵ: 'オ',\n  ｶ: 'カ',\n  ｷ: 'キ',\n  ｸ: 'ク',\n  ｹ: 'ケ',\n  ｺ: 'コ',\n  ｻ: 'サ',\n  ｼ: 'シ',\n  ｽ: 'ス',\n  ｾ: 'セ',\n  ｿ: 'ソ',\n  ﾀ: 'タ',\n  ﾁ: 'チ',\n  ﾂ: 'ツ',\n  ﾃ: 'テ',\n  ﾄ: 'ト',\n  ﾅ: 'ナ',\n  ﾆ: 'ニ',\n  ﾇ: 'ヌ',\n  ﾈ: 'ネ',\n  ﾉ: 'ノ',\n  ﾊ: 'ハ',\n  ﾋ: 'ヒ',\n  ﾌ: 'フ',\n  ﾍ: 'ヘ',\n  ﾎ: 'ホ',\n  ﾏ: 'マ',\n  ﾐ: 'ミ',\n  ﾑ: 'ム',\n  ﾒ: 'メ',\n  ﾓ: 'モ',\n  ﾔ: 'ヤ',\n  ﾕ: 'ユ',\n  ﾖ: 'ヨ',\n  ﾗ: 'ラ',\n  ﾘ: 'リ',\n  ﾙ: 'ル',\n  ﾚ: 'レ',\n  ﾛ: 'ロ',\n  ﾜ: 'ワ',\n  ｦ: 'ヲ',\n  ﾝ: 'ン',\n  ｧ: 'ァ',\n  ｨ: 'ィ',\n  ｩ: 'ゥ',\n  ｪ: 'ェ',\n  ｫ: 'ォ',\n  ｯ: 'ッ',\n  ｬ: 'ャ',\n  ｭ: 'ュ',\n  ｮ: 'ョ',\n  ﾞ: '゛',\n  ﾟ: '゜',\n};\n/** 全角カナ変換用正規表現 @type {RegExp} */\nconst _fi_FULL_WIDTH_KANA_LIST_REG = new RegExp(\n  '(' + Object.keys(_fi_FULL_WIDTH_KANA_LIST).join('|') + ')',\n  'g'\n);\n/** 濁点・半濁点カナ変換マッピング @type {Object} */\nconst _fi_TURBIDITY_KANA_LIST = {\n  'カ゛': 'ガ',\n  'キ゛': 'ギ',\n  'ク゛': 'グ',\n  'ケ゛': 'ゲ',\n  'コ゛': 'ゴ',\n  'サ゛': 'ザ',\n  'シ゛': 'ジ',\n  'ス゛': 'ズ',\n  'セ゛': 'ゼ',\n  'ソ゛': 'ゾ',\n  'タ゛': 'ダ',\n  'チ゛': 'ヂ',\n  'ツ゛': 'ヅ',\n  'テ゛': 'デ',\n  'ト゛': 'ド',\n  'ハ゛': 'バ',\n  'ヒ゛': 'ビ',\n  'フ゛': 'ブ',\n  'ヘ゛': 'ベ',\n  'ホ゛': 'ボ',\n  'ハ゜': 'パ',\n  'ヒ゜': 'ピ',\n  'フ゜': 'プ',\n  'ヘ゜': 'ペ',\n  'ホ゜': 'ポ',\n  'ウ゛': 'ヴ',\n  'ワ゛': 'ヷ',\n  'ヲ゛': 'ヺ',\n};\n/** 濁点・半濁点カナ変換用正規表現 @type {RegExp} */\nconst _fi_TURBIDITY_KANA_LIST_REG = new RegExp(\n  '(' + Object.keys(_fi_TURBIDITY_KANA_LIST).join('|') + ')',\n  'g'\n);\n/** 半角カナ変換マッピング @type {Object} */\nconst _fi_HALF_WIDTH_KANA_LIST = {\n  ア: 'ｱ',\n  イ: 'ｲ',\n  ウ: 'ｳ',\n  エ: 'ｴ',\n  オ: 'ｵ',\n  カ: 'ｶ',\n  キ: 'ｷ',\n  ク: 'ｸ',\n  ケ: 'ｹ',\n  コ: 'ｺ',\n  サ: 'ｻ',\n  シ: 'ｼ',\n  ス: 'ｽ',\n  セ: 'ｾ',\n  ソ: 'ｿ',\n  タ: 'ﾀ',\n  チ: 'ﾁ',\n  ツ: 'ﾂ',\n  テ: 'ﾃ',\n  ト: 'ﾄ',\n  ナ: 'ﾅ',\n  ニ: 'ﾆ',\n  ヌ: 'ﾇ',\n  ネ: 'ﾈ',\n  ノ: 'ﾉ',\n  ハ: 'ﾊ',\n  ヒ: 'ﾋ',\n  フ: 'ﾌ',\n  ヘ: 'ﾍ',\n  ホ: 'ﾎ',\n  マ: 'ﾏ',\n  ミ: 'ﾐ',\n  ム: 'ﾑ',\n  メ: 'ﾒ',\n  モ: 'ﾓ',\n  ヤ: 'ﾔ',\n  ユ: 'ﾕ',\n  ヨ: 'ﾖ',\n  ラ: 'ﾗ',\n  リ: 'ﾘ',\n  ル: 'ﾙ',\n  レ: 'ﾚ',\n  ロ: 'ﾛ',\n  ワ: 'ﾜ',\n  ヲ: 'ｵ',\n  ン: 'ﾝ',\n  ガ: 'ｶﾞ',\n  ギ: 'ｷﾞ',\n  グ: 'ｸﾞ',\n  ゲ: 'ｹﾞ',\n  ゴ: 'ｺﾞ',\n  ザ: 'ｻﾞ',\n  ジ: 'ｼﾞ',\n  ズ: 'ｽﾞ',\n  ゼ: 'ｾﾞ',\n  ゾ: 'ｿﾞ',\n  ダ: 'ﾀﾞ',\n  ヂ: 'ﾁﾞ',\n  ヅ: 'ﾂﾞ',\n  デ: 'ﾃﾞ',\n  ド: 'ﾄﾞ',\n  バ: 'ﾊﾞ',\n  ビ: 'ﾋﾞ',\n  ブ: 'ﾌﾞ',\n  ベ: 'ﾍﾞ',\n  ボ: 'ﾎﾞ',\n  パ: 'ﾊﾟ',\n  ピ: 'ﾋﾟ',\n  プ: 'ﾌﾟ',\n  ペ: 'ﾍﾟ',\n  ポ: 'ﾎﾟ',\n  ヴ: 'ｳﾞ',\n  ヷ: 'ﾜﾞ',\n  ヺ: 'ｵﾞ',\n  ァ: 'ｱ',\n  ィ: 'ｲ',\n  ゥ: 'ｳ',\n  ェ: 'ｴ',\n  ォ: 'ｵ',\n  ッ: 'ﾂ',\n  ャ: 'ﾔ',\n  ュ: 'ﾕ',\n  ョ: 'ﾖ',\n  '゛': 'ﾞ',\n  '゜': 'ﾟ',\n};\n/** 半角カナ変換用正規表現 @type {RegExp} */\nconst _fi_HALF_WIDTH_KANA_LIST_REG = new RegExp(\n  '(' + Object.keys(_fi_HALF_WIDTH_KANA_LIST).join('|') + ')',\n  'g'\n);\n/** 銀行用カナ変換マッピング @type {Object} */\nconst _fi_BANK_KANA_LIST = {\n  ｧ: 'ｱ',\n  ｨ: 'ｲ',\n  ｩ: 'ｳ',\n  ｪ: 'ｴ',\n  ｫ: 'ｵ',\n  ｯ: 'ﾂ',\n  ｬ: 'ﾔ',\n  ｭ: 'ﾕ',\n  ｮ: 'ﾖ',\n  '（': '(',\n  '）': ')',\n  '・': '.',\n  ー: '-',\n  '‐': '-',\n  '－': '-',\n  '　': ' ',\n  '゛': 'ﾞ',\n  '゜': 'ﾟ',\n};\n/** 銀行用カナ変換用正規表現 @type {RegExp} */\nconst _fi_BANK_KANA_LIST_REG = new RegExp(\n  '(' + Object.keys(_fi_BANK_KANA_LIST).join('|') + ')',\n  'g'\n);\n/** 法人略語マッピング @type {Object} */\nconst _fi_CORPORATE_ABBREVIATIONS_LIST = {\n  株式会社: 'ｶ',\n  ｶﾌﾞｼｷｶﾞｲｼﾔ: 'ｶ',\n  有限会社: 'ﾕ',\n  ﾕｳｹﾞﾝｶﾞｲｼﾔ: 'ﾕ',\n  合名会社: 'ﾒ',\n  ｺﾞｳﾒｲｶﾞｲｼﾔ: 'ﾒ',\n  合資会社: 'ｼ',\n  ｺﾞｳｼｶﾞｲｼﾔ: 'ｼ',\n  合同会社: 'ﾄﾞ',\n  ｺﾞｳﾄﾞｳｶﾞｲｼﾔ: 'ﾄﾞ',\n  医療法人社団: 'ｲ',\n  ｲﾘﾖｳﾎｳｼﾞﾝｼﾔﾀﾞﾝ: 'ｲ',\n  医療法人財団: 'ｲ',\n  ｲﾘﾖｳﾎｳｼﾞﾝｻﾞｲﾀﾞﾝ: 'ｲ',\n  社会医療法人: 'ｲ',\n  ｼﾔｶｲｲﾘﾖｳﾎｳｼﾞﾝ: 'ｲ',\n  医療法人: 'ｲ',\n  ｲﾘﾖｳﾎｳｼﾞﾝ: 'ｲ',\n  一般財団法人: 'ｻﾞｲ',\n  ｲﾂﾊﾟﾝｻﾞｲﾀﾞﾝﾎｳｼﾞﾝ: 'ｻﾞｲ',\n  公益財団法人: 'ｻﾞｲ',\n  ｺｳｴｷｻﾞｲﾀﾞﾝﾎｳｼﾞﾝ: 'ｻﾞｲ',\n  財団法人: 'ｻﾞｲ',\n  ｻﾞｲﾀﾞﾝﾎｳｼﾞﾝ: 'ｻﾞｲ',\n  一般社団法人: 'ｼﾔ',\n  ｲﾂﾊﾟﾝｼﾔﾀﾞﾝﾎｳｼﾞﾝ: 'ｼﾔ',\n  公益社団法人: 'ｼﾔ',\n  ｺｳｴｷｼﾔﾀﾞﾝﾎｳｼﾞﾝ: 'ｼﾔ',\n  社団法人: 'ｼﾔ',\n  ｼﾔﾀﾞﾝﾎｳｼﾞﾝ: 'ｼﾔ',\n  宗教法人: 'ｼﾕｳ',\n  ｼﾕｳｷﾖｳﾎｳｼﾞﾝ: 'ｼﾕｳ',\n  学校法人: 'ｶﾞｸ',\n  ｶﾞﾂｺｳﾎｳｼﾞﾝ: 'ｶﾞｸ',\n  社会福祉法人: 'ﾌｸ',\n  ｼﾔｶｲﾌｸｼﾎｳｼﾞﾝ: 'ﾌｸ',\n  更生保護法人: 'ﾎｺﾞ',\n  ｺｳｾｲﾎｺﾞﾎｳｼﾞﾝ: 'ﾎｺﾞ',\n  相互会社: 'ｿ',\n  ｿｳｺﾞｶﾞｲｼﾔ: 'ｿ',\n  特定非営利活動法人: 'ﾄｸﾋ',\n  ﾄｸﾃｲﾋｴｲﾘｶﾂﾄﾞｳﾎｳｼﾞﾝ: 'ﾄｸﾋ',\n  地方独立行政法人: 'ﾁﾄﾞｸ',\n  ﾁﾎｳﾄﾞｸﾘﾂｷﾞﾖｳｾｲﾎｳｼﾞﾝ: 'ﾁﾄﾞｸ',\n  独立行政法人: 'ﾄﾞｸ',\n  ﾄﾞｸﾘﾂｷﾞﾖｳｾｲﾎｳｼﾞﾝ: 'ﾄﾞｸ',\n  中期目標管理法人: 'ﾓｸ',\n  ﾁﾕｳｷﾓｸﾋﾖｳｶﾝﾘﾎｳｼﾞﾝ: 'ﾓｸ',\n  国立研究開発法人: 'ｹﾝ',\n  ｺｸﾘﾂｹﾝｷﾕｳｶｲﾊﾂﾎｳｼﾞﾝ: 'ｹﾝ',\n  行政執行法人: 'ｼﾂ',\n  ｷﾞﾖｳｾｲｼﾂｺｳﾎｳｼﾞﾝ: 'ｼﾂ',\n  弁護士法人: 'ﾍﾞﾝ',\n  ﾍﾞﾝｺﾞｼﾎｳｼﾞﾝ: 'ﾍﾞﾝ',\n  有限責任中間法人: 'ﾁﾕｳ',\n  ﾕｳｹﾞﾝｾｷﾆﾝﾁﾕｳｶﾝﾎｳｼﾞﾝ: 'ﾁﾕｳ',\n  無限責任中間法人: 'ﾁﾕｳ',\n  ﾑｹﾞﾝｾｷﾆﾝﾁﾕｳｶﾝﾎｳｼﾞﾝ: 'ﾁﾕｳ',\n  行政書士法人: 'ｷﾞﾖ',\n  ｷﾞﾖｳｾｲｼﾖｼﾎｳｼﾞﾝ: 'ｷﾞﾖ',\n  司法書士法人: 'ｼﾎｳ',\n  ｼﾎｳｼﾖｼﾎｳｼﾞﾝ: 'ｼﾎｳ',\n  税理士法人: 'ｾﾞｲ',\n  ｾﾞｲﾘｼﾎｳｼﾞﾝ: 'ｾﾞｲ',\n  国立大学法人: 'ﾀﾞｲ',\n  ｺｸﾘﾂﾀﾞｲｶﾞｸﾎｳｼﾞﾝ: 'ﾀﾞｲ',\n  公立大学法人: 'ﾀﾞｲ',\n  ｺｳﾘﾂﾀﾞｲｶﾞｸﾎｳｼﾞﾝ: 'ﾀﾞｲ',\n  農事組合法人: 'ﾉｳ',\n  ﾉｳｼﾞｸﾐｱｲﾎｳｼﾞﾝ: 'ﾉｳ',\n  管理組合法人: 'ｶﾝﾘ',\n  ｶﾝﾘｸﾐｱｲﾎｳｼﾞﾝ: 'ｶﾝﾘ',\n  社会保険労務士法人: 'ﾛｳﾑ',\n  ｼﾔｶｲﾎｹﾝﾛｳﾑｼﾎｳｼﾞﾝ: 'ﾛｳﾑ',\n};\n/** 法人略語用正規表現 @type {RegExp} */\nconst _fi_CORPORATE_ABBREVIATIONS_LIST_REG = new RegExp(\n  '(' + Object.keys(_fi_CORPORATE_ABBREVIATIONS_LIST).join('|') + ')',\n  ''\n);\n/** 営業所マッピング @type {Object} */\nconst _fi_SALES_OFFICES_LIST = {\n  営業所: 'ｴｲ',\n  ｴｲｷﾞﾖｳｼﾖ: 'ｴｲ',\n  ｴｲｷﾞﾖｳｼﾞﾖ: 'ｴｲ',\n  出張所: 'ｼﾕﾂ',\n  ｼﾕﾂﾁﾖｳｼﾖ: 'ｼﾕﾂ',\n  ｼﾕﾂﾁﾖｳｼﾞﾖ: 'ｼﾕﾂ',\n};\n/** 営業所用正規表現 @type {RegExp} */\nconst _fi_SALES_OFFICES_LIST_REG = new RegExp(\n  '(' + Object.keys(_fi_SALES_OFFICES_LIST).join('|') + ')',\n  ''\n);\n/** 事業マッピング @type {Object} */\nconst _fi_BUSINESS_LIST = {\n  国民健康保険団体連合会: 'ｺｸﾎﾚﾝ',\n  ｺｸﾐﾝｹﾝｺｳﾎｹﾝﾀﾞﾝﾀｲﾚﾝｺﾞｳｶｲ: 'ｺｸﾎﾚﾝ',\n  国家公務員共済組合連合会: 'ｺｸｷﾖｳﾚﾝ',\n  ｺﾂｶｺｳﾑｲﾝｷﾖｳｻｲｸﾐｱｲﾚﾝｺﾞｳｶｲ: 'ｺｸｷﾖｳﾚﾝ',\n  経済農業協同組合連合会: 'ｹｲｻﾞｲﾚﾝ',\n  ｹｲｻﾞｲﾉｳｷﾞﾖｳｷﾖｳﾄﾞｳｸﾐｱｲﾚﾝｺﾞｳｶｲ: 'ｹｲｻﾞｲﾚﾝ',\n  共済農業協同組合連合会: 'ｷﾖｳｻｲﾚﾝ',\n  ｷﾖｳｻｲﾉｳｷﾞﾖｳｷﾖｳﾄﾞｳｸﾐｱｲﾚﾝｺﾞｳｶｲ: 'ｷﾖｳｻｲﾚﾝ',\n  農業協同組合連合会: 'ﾉｳｷﾖｳﾚﾝ',\n  ﾉｳｷﾞﾖｳｷﾖｳﾄﾞｳｸﾐｱｲﾚﾝｺﾞｳｶｲ: 'ﾉｳｷﾖｳﾚﾝ',\n  漁業協同組合連合会: 'ｷﾞﾖﾚﾝ',\n  ｷﾞﾖｷﾞﾖｳｷﾖｳﾄﾞｳｸﾐｱｲﾚﾝｺﾞｳｶｲ: 'ｷﾞﾖﾚﾝ',\n  連合会: 'ﾚﾝ',\n  ﾚﾝｺﾞｳｶｲ: 'ﾚﾝ',\n  共済組合: 'ｷﾖｳｻｲ',\n  ｷﾖｳｻｲｸﾐｱｲ: 'ｷﾖｳｻｲ',\n  生活協同組合: 'ｾｲｷﾖｳ',\n  ｾｲｶﾂｷﾖｳﾄﾞｳｸﾐｱｲ: 'ｾｲｷﾖｳ',\n  食糧販売協同組合: 'ｼﾖｸﾊﾝｷﾖｳ',\n  ｼﾖｸﾘﾖｳﾊﾝﾊﾞｲｷﾖｳﾄﾞｳｸﾐｱｲ: 'ｼﾖｸﾊﾝｷﾖｳ',\n  漁業協同組合: 'ｷﾞﾖｷﾖｳ',\n  ｷﾞﾖｷﾞﾖｳｷﾖｳﾄﾞｳｸﾐｱｲ: 'ｷﾞﾖｷﾖｳ',\n  協同組合: 'ｷﾖｳｸﾐ',\n  ｷﾖｳﾄﾞｳｸﾐｱｲ: 'ｷﾖｳｸﾐ',\n  生命保険: 'ｾｲﾒｲ',\n  ｾｲﾒｲﾎｹﾝ: 'ｾｲﾒｲ',\n  海上火災保険: 'ｶｲｼﾞﾖｳ',\n  ｶｲｼﾞﾖｳｶｻｲﾎｹﾝ: 'ｶｲｼﾞﾖｳ',\n  火災海上保険: 'ｶｻｲ',\n  ｶｻｲｶｲｼﾞﾖｳﾎｹﾝ: 'ｶｻｲ',\n  国民健康保険組合: 'ｺｸﾎ',\n  ｺｸﾐﾝｹﾝｺｳﾎｹﾝｸﾐｱｲ: 'ｺｸﾎ',\n  健康保険組合: 'ｹﾝﾎﾟ',\n  ｹﾝｺｳﾎｹﾝｸﾐｱｲ: 'ｹﾝﾎﾟ',\n  社会保険診療報酬支払基金: 'ｼﾔﾎ',\n  ｼﾔｶｲﾎｹﾝｼﾝﾘﾖｳﾎｳｼﾕｳｼﾊﾗｲｷｷﾝ: 'ｼﾔﾎ',\n  厚生年金基金: 'ｺｳﾈﾝ',\n  ｺｳｾｲﾈﾝｷﾝｷｷﾝ: 'ｺｳﾈﾝ',\n  従業員組合: 'ｼﾞﾕｳｸﾐ',\n  ｼﾞﾕｳｷﾞﾖｳｲﾝｸﾐｱｲ: 'ｼﾞﾕｳｸﾐ',\n  労働組合: 'ﾛｳｸﾐ',\n  ﾛｳﾄﾞｳｸﾐｱｲ: 'ﾛｳｸﾐ',\n  公共職業安定所: 'ｼﾖｸｱﾝ',\n  ｺｳｷﾖｳｼﾖｸｷﾞﾖｳｱﾝﾃｲｼﾖ: 'ｼﾖｸｱﾝ',\n  ｺｳｷﾖｳｼﾖｸｷﾞﾖｳｱﾝﾃｲｼﾞﾖ: 'ｼﾖｸｱﾝ',\n  特別養護老人ホーム: 'ﾄｸﾖｳ',\n  ﾄｸﾍﾞﾂﾖｳｺﾞﾛｳｼﾞﾝﾎｰﾑ: 'ﾄｸﾖｳ',\n  有限責任事業組合: 'ﾕｳｸﾐ',\n  ﾕｳｹﾞﾝｾｷﾆﾝｼﾞｷﾞﾖｳｸﾐｱｲ: 'ﾕｳｸﾐ',\n};\n/** 事業用正規表現 @type {RegExp} */\nconst _fi_BUSINESS_LIST_REG = new RegExp('(' + Object.keys(_fi_BUSINESS_LIST).join('|') + ')', '');\n/**\n * 文字列を全角カナ（濁点・半濁点付き含む）に変換します。\n * @function\n * @param {string} inputStr 変換する文字列\n * @param {boolean} [hiraganaSw=true] ひらがなをカタカナに変換するか（true:変換する/false:変換しない）\n * @returns {string} 全角カナに変換された文字列\n * @throws {Error} 変換対象が文字列でない場合\n * @private\n * @example\n *   _fi_convert_to_full_width_kana('ﾀﾛｳ'); // => 'タロウ'\n */\nconst _fi_convert_to_full_width_kana = (inputStr, hiraganaSw = true) => {\n  if (typeof inputStr !== 'string')\n    throw new _fi_FinancialInstitutionError('変換する文字列は文字列である必要があります', 'logic');\n  let fullWidthKana = inputStr;\n  if (hiraganaSw) {\n    fullWidthKana = String(fullWidthKana).replace(/[\\u3041-\\u3096]/g, (c) =>\n      String.fromCharCode(c.charCodeAt(0) + 96)\n    );\n  }\n  fullWidthKana = fullWidthKana.replace(\n    _fi_FULL_WIDTH_KANA_LIST_REG,\n    (c) => _fi_FULL_WIDTH_KANA_LIST[c]\n  );\n  fullWidthKana = fullWidthKana.replace(\n    _fi_TURBIDITY_KANA_LIST_REG,\n    (c) => _fi_TURBIDITY_KANA_LIST[c]\n  );\n  return fullWidthKana;\n};\n/**\n * 文字列を半角カナに変換します。\n * @function\n * @param {string} inputStr 変換する文字列\n * @returns {string} 半角カナに変換された文字列\n * @throws {Error} 変換対象が文字列でない場合\n * @private\n * @example\n *   _fi_convert_to_half_width_kana('タロウ'); // => 'ﾀﾛｳ'\n */\nconst _fi_convert_to_half_width_kana = (inputStr) => {\n  if (typeof inputStr !== 'string')\n    throw new _fi_FinancialInstitutionError('変換する文字列は文字列である必要があります', 'logic');\n  const fullWidthKana = _fi_convert_to_full_width_kana(inputStr);\n  return fullWidthKana.replace(_fi_HALF_WIDTH_KANA_LIST_REG, (c) => _fi_HALF_WIDTH_KANA_LIST[c]);\n};\n/**\n * 文字列を半角英数字・半角カナ・記号に変換します。\n * @function\n * @param {string} inputStr 変換する文字列\n * @returns {string} 半角英数字・半角カナ・記号に変換された文字列（大文字化）\n * @throws {Error} 変換対象が文字列でない場合\n * @private\n * @example\n *   _fi_convert_to_single_byte_characters('ＡＢＣ１２３'); // => 'ABC123'\n */\nconst _fi_convert_to_single_byte_characters = (inputStr) => {\n  if (typeof inputStr !== 'string')\n    throw new _fi_FinancialInstitutionError('変換する文字列は文字列である必要があります', 'logic');\n  const hyphenProcess = inputStr.replace(\n    /[\\uFF0D\\u2010\\u2011\\u2013\\u2014\\u2212\\u30FC\\u2015\\uFF70]/g,\n    '-'\n  );\n  const halfWidthKana = _fi_convert_to_half_width_kana(hyphenProcess);\n  const singleByteCharacters = halfWidthKana\n    .replace(/[Ａ-Ｚａ-ｚ０-９！-～]/g, (c) => String.fromCharCode(c.charCodeAt(0) - 0xfee0))\n    .toUpperCase();\n  return singleByteCharacters;\n};\n/**\n * 全角数字や漢数字を半角数字に変換します。\n * @function\n * @param {string} inputStr 変換する文字列\n * @returns {string} 半角数字に変換された文字列\n * @throws {Error} 変換対象が文字列でない場合、または未入力の場合\n * @private\n * @example\n *   _fi_convert_to_single_byte_numbers('１２３四五'); // => '12345'\n */\nconst _fi_convert_to_single_byte_numbers = (inputStr = '') => {\n  if (typeof inputStr !== 'string')\n    throw new _fi_FinancialInstitutionError('変換する文字列は文字列である必要があります', 'logic');\n  if (inputStr.length === 0)\n    throw new _fi_FinancialInstitutionError('変換対象の文字列が未入力です', 'logic');\n  const _fi_convertKanjiNumerals = (kanjiStr = '') => {\n    const _fi_parseKanjiNumber = (kanji) => {\n      const digits = {\n        〇: 0,\n        一: 1,\n        二: 2,\n        三: 3,\n        四: 4,\n        五: 5,\n        六: 6,\n        七: 7,\n        八: 8,\n        九: 9,\n      };\n      const multipliers = { 十: 10, 百: 100, 千: 1000, 万: 10000 };\n      let current = 0;\n      let temp = 0;\n      for (let c = 0; c < kanji.length; c++) {\n        const char = kanji[c];\n        if (char in digits) {\n          current = digits[char];\n        } else if (char in multipliers) {\n          if (current === 0) current = 1;\n          temp += current * multipliers[char];\n          current = 0;\n        }\n      }\n      return temp + current;\n    };\n    return kanjiStr.replace(/[〇一二三四五六七八九十百千]+/g, (match) =>\n      _fi_parseKanjiNumber(match)\n    );\n  };\n  const _fi_convertFullWidthDigits = (numStr = '') => {\n    return numStr.replace(/[０-９]/g, (char) => String.fromCharCode(char.charCodeAt(0) - 0xfee0));\n  };\n  let result = _fi_convertKanjiNumerals(inputStr);\n  result = _fi_convertFullWidthDigits(result);\n  return result;\n};\n// --- APIレスポンスバリデーション ---\n/**\n * 銀行APIレスポンスのバリデーション（内部関数）\n * @function\n * @param {object} result APIレスポンス\n * @throws {Error} 不正なレスポンスの場合\n * @private\n */\nconst _fi_validateBankResponse = (result) => {\n  if (\n    !result ||\n    typeof result.code !== 'string' ||\n    typeof result.normalize !== 'object' ||\n    typeof result.normalize.name !== 'string' ||\n    typeof result.kana !== 'string'\n  ) {\n    throw new _fi_FinancialInstitutionError('APIレスポンスが不正です（銀行情報）', 'ajax');\n  }\n};\n/**\n * 銀行APIレスポンス（配列）のバリデーション（内部関数）\n * @function\n * @param {object[]} result APIレスポンス配列\n * @throws {Error} 不正なレスポンスの場合\n * @private\n */\nconst _fi_validateBankArrayResponse = (result) => {\n  if (\n    !Array.isArray(result) ||\n    result.length === 0 ||\n    !result.every(\n      (row) =>\n        typeof row.code === 'string' &&\n        typeof row.normalize === 'object' &&\n        typeof row.normalize.name === 'string' &&\n        typeof row.kana === 'string'\n    )\n  ) {\n    throw new _fi_FinancialInstitutionError('APIレスポンスが不正です（銀行情報リスト）', 'ajax');\n  }\n};\n/**\n * 支店APIレスポンスのバリデーション（内部関数）\n * @function\n * @param {object} result APIレスポンス\n * @throws {Error} 不正なレスポンスの場合\n * @private\n */\nconst _fi_validateBranchResponse = (result) => {\n  if (\n    !result ||\n    typeof result.code !== 'string' ||\n    typeof result.normalize !== 'object' ||\n    typeof result.normalize.name !== 'string' ||\n    typeof result.kana !== 'string'\n  ) {\n    throw new _fi_FinancialInstitutionError('APIレスポンスが不正です（支店情報）', 'ajax');\n  }\n};\n/**\n * 支店APIレスポンス（配列）のバリデーション（内部関数）\n * @function\n * @param {object[]} result APIレスポンス配列\n * @throws {Error} 不正なレスポンスの場合\n * @private\n */\nconst _fi_validateBranchArrayResponse = (result) => {\n  if (\n    !Array.isArray(result) ||\n    result.length === 0 ||\n    !result.every(\n      (row) =>\n        typeof row.code === 'string' &&\n        typeof row.normalize === 'object' &&\n        typeof row.normalize.name === 'string' &&\n        typeof row.kana === 'string'\n    )\n  ) {\n    throw new _fi_FinancialInstitutionError('APIレスポンスが不正です（支店情報リスト）', 'ajax');\n  }\n};\n/**\n * 全銀手順で許可される文字種のみ許可するバリデーション関数。\n * @function\n * @param {string} str 入力文字列\n * @returns {boolean} 許可される場合true、許可されない文字が含まれる場合false\n * @throws {Error} 入力が文字列でない場合\n * @private\n * @example\n *   _fi_is_zengin_allowed_chars('ﾀﾛｳ123'); // => true\n */\nconst _fi_is_zengin_allowed_chars = (str) => {\n  if (typeof str !== 'string')\n    throw new _fi_FinancialInstitutionError('入力文字列は文字列である必要があります', 'logic');\n  // 半角英数字・半角カナ・許可記号のみ\n  // 許可記号は用途に応じて調整可能\n  const zenginReg = /^[0-9A-Z !\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~｡｢｣､･\\uFF61-\\uFF9F]+$/;\n  return zenginReg.test(str);\n};\n/**\n * 指定した日付が国民の祝日かどうかを判定し、祝日名またはnullをコールバックで返す（非同期）\n *\n * @function _fi_getNationalHolidayName\n * @param {string} date_str - ISO 8601拡張形式（YYYY-MM-DD）の日付文字列\n * @param {(holidayName: string|null) => void} callback - 祝日名（該当しなければnull）を返すコールバック関数\n * @returns {void}\n * @throws {_nh_FinancialInstitutionError} date_strやcallbackの型が不正な場合\n * @private\n * @example\n * _fi_getNationalHolidayName('2025-09-15', (name) => {\n *   if (name) {\n *     console.log('祝日:', name);\n *   } else {\n *     console.log('祝日ではありません');\n *   }\n * });\n *\n * @remarks\n * - 1948-07-20以前の日付は祝日判定対象外です。\n * - APIレスポンスの型チェックを行い、不正なデータは無視します。\n * - fetch通信エラーやAPI異常時は必ずnullを返します。\n */\nconst _fi_getNationalHolidayName = (date_str, callback) => {\n  if (typeof date_str !== 'string')\n    throw new _fi_FinancialInstitutionError('検索対象の日付は文字列である必要があります', 'logic');\n  if (typeof callback !== 'function')\n    throw new _fi_FinancialInstitutionError('コールバックは関数である必要があります', 'logic');\n  if (!date_str) return callback(null);\n  if (date_str < '1948-07-20') return callback(null);\n  fetch(_fi_HOLIDAY_API_BASE_URL + '/' + date_str)\n    .then((res) => {\n      if (!res.ok) {\n        throw new Error('祝日APIのレスポンスが不正です: ' + res.status);\n      }\n      return res.json();\n    })\n    .then((result) => {\n      // 祝日でない場合 { error: \"not_found\" }\n      if (result && typeof result === 'object') {\n        if (result.error === 'not_found') {\n          callback(null);\n          return;\n        }\n        if (typeof result.date === 'string' && typeof result.name === 'string') {\n          callback(result.name);\n          return;\n        }\n      }\n      // それ以外はnull\n      callback(null);\n    })\n    .catch((_err) => {\n      // 通信エラーやAPI異常時も必ずnullで抜ける\n      callback(null);\n    });\n};\n\n/**\n * 銀行番号（4桁）または銀行名（部分一致可）から銀行情報を取得します。\n * @function\n * @param {string} bankChar - 銀行番号（4桁の数字文字列）または銀行名（部分一致可）。\n * @param {(result: {bank_number: string, bank_name: string, bank_name_kana: string}) => void} successCallback - 正常時に呼ばれるコールバック。引数 result の内容:\n *   - bank_number: 銀行番号（4桁）\n *   - bank_name: 銀行名（正規化済み）\n *   - bank_name_kana: 銀行名カナ（半角カナ）\n * @param {(err: Error & {type?: 'logic'|'ajax'}) => void} failureCallback - エラー時に呼ばれるコールバック。err.type でエラー種別（logic:入力不備/ajax:API通信・データ不備）を判別。\n * @returns {void}\n * @throws {Error} 引数の型が不正な場合\n * @public\n * @example <caption>銀行番号で取得</caption>\n * findBank('0005',\n *   (result) => {\n *     console.log(result.bank_number); // '0005'\n *     console.log(result.bank_name);   // '三菱ＵＦＪ銀行'\n *     console.log(result.bank_name_kana); // 'ﾐﾂﾋﾞｼﾕｰｴﾌｼﾞｪｲｷﾞﾝｺｳ'\n *   },\n *   (err) => {\n *     alert(err.message);\n *   }\n * );\n *\n * @example <caption>銀行名で取得（部分一致）</caption>\n * findBank('みずほ',\n *   (result) => {\n *     // ...\n *   },\n *   (err) => {\n *     // ...\n *   }\n * );\n *\n * @example <caption>エラー時のコールバック</caption>\n * findBank('',\n *   (result) => {},\n *   (err) => {\n *     if (err.type === 'logic') {\n *       alert('入力エラー: ' + err.message);\n *     } else {\n *       alert('APIエラー: ' + err.message);\n *     }\n *   }\n * );\n */\nconst findBank = (bankChar, successCallback, failureCallback) => {\n  if (typeof bankChar !== 'string')\n    throw new _fi_FinancialInstitutionError(\n      '銀行番号（4桁）または銀行名（部分一致可）は文字列である必要があります',\n      'logic'\n    );\n  if (typeof successCallback !== 'function')\n    throw new _fi_FinancialInstitutionError(\n      '正常時に呼ばれるコールバックは関数である必要があります',\n      'logic'\n    );\n  if (typeof failureCallback !== 'function')\n    throw new _fi_FinancialInstitutionError(\n      'エラー時に呼ばれるコールバックは関数である必要があります',\n      'logic'\n    );\n  if (bankChar.length === 0) {\n    if (failureCallback) {\n      failureCallback(\n        new _fi_FinancialInstitutionError('銀行番号または銀行名が未入力です', 'logic')\n      );\n    }\n    return;\n  }\n  const bankCharSbn = Number(_fi_convert_to_single_byte_numbers(bankChar));\n  // 銀行番号で検索\n  if (bankCharSbn >= 0 && bankCharSbn <= Number('9'.repeat(_fi_BANK_CODE_LENGTH))) {\n    const bankNumberTemp = '0'.repeat(_fi_BANK_CODE_LENGTH) + String(bankCharSbn);\n    const bankNumber = bankNumberTemp.slice(-_fi_BANK_CODE_LENGTH);\n    fetch(_fi_BANK_API_BASE_URL + '/banks/' + bankNumber + '.json')\n      .then((response) => {\n        if (!response.ok) {\n          if (response.status === 404) {\n            throw new _fi_FinancialInstitutionError(\n              `銀行番号「${bankNumber}」に該当する銀行が見つかりません`,\n              'ajax'\n            );\n          } else if (response.status >= 500) {\n            throw new _fi_FinancialInstitutionError('サーバーエラーが発生しました', 'ajax');\n          } else {\n            throw new _fi_FinancialInstitutionError(`通信エラー（${response.status}）`, 'ajax');\n          }\n        }\n        return response.json();\n      })\n      .then((result) => {\n        _fi_validateBankResponse(result);\n        successCallback({\n          bank_number: result.code,\n          bank_name: result.normalize.name,\n          bank_name_kana: convertAccountHolderKana(result.kana, false),\n        });\n      })\n      .catch((err) => {\n        if (failureCallback) {\n          // fetch失敗時も「銀行が見つかりません」と返す\n          let message = '銀行が見つかりません';\n          if (err instanceof _fi_FinancialInstitutionError) {\n            message = err.message;\n          }\n          failureCallback(new _fi_FinancialInstitutionError(message, 'ajax'));\n        }\n      });\n    return;\n  }\n  // 銀行名で検索\n  fetch(_fi_BANK_API_BASE_URL + '/banks/search.json?name=' + encodeURIComponent(bankChar))\n    .then((response) => {\n      if (!response.ok) {\n        if (response.status === 404) {\n          throw new _fi_FinancialInstitutionError(\n            `銀行名「${bankChar}」に該当する銀行が見つかりません`,\n            'ajax'\n          );\n        } else if (response.status >= 500) {\n          throw new _fi_FinancialInstitutionError('サーバーエラーが発生しました', 'ajax');\n        } else {\n          throw new _fi_FinancialInstitutionError(`通信エラー（${response.status}）`, 'ajax');\n        }\n      }\n      return response.json();\n    })\n    .then((result) => {\n      try {\n        _fi_validateBankArrayResponse(result);\n      } catch (e) {\n        if (failureCallback) return failureCallback(e);\n        return;\n      }\n      if (result.length === 1) {\n        successCallback({\n          bank_number: result[0].code,\n          bank_name: result[0].normalize.name,\n          bank_name_kana: convertAccountHolderKana(result[0].kana, false),\n        });\n      } else {\n        if (failureCallback) {\n          failureCallback(\n            new _fi_FinancialInstitutionError(\n              `銀行名「${bankChar}」に該当する銀行が複数見つかりました。より詳細な名称で再検索してください。`,\n              'ajax'\n            )\n          );\n        }\n      }\n    })\n    .catch((err) => {\n      if (failureCallback) {\n        if (!(err instanceof _fi_FinancialInstitutionError)) {\n          err = new _fi_FinancialInstitutionError(\n            err && err.message ? err.message : 'ネットワークエラーまたは不明なエラー',\n            'ajax'\n          );\n        }\n        failureCallback(err);\n      }\n    });\n};\n\n/**\n * 銀行番号（4桁）または銀行名、および支店番号（3桁）または支店名から支店情報を取得します。\n * @function\n * @param {string} bankChar - 銀行番号（4桁の数字文字列）または銀行名（部分一致可）。\n * @param {string} bankBranchChar - 支店番号（3桁の数字文字列）または支店名（部分一致可）。\n * @param {(result: {bank_branch_number: string, bank_branch_name: string, bank_branch_name_kana: string}) => void} successCallback - 正常時に呼ばれるコールバック。引数 result の内容:\n *   - bank_branch_number: 支店番号（3桁）\n *   - bank_branch_name: 支店名（正規化済み）\n *   - bank_branch_name_kana: 支店名カナ（半角カナ）\n * @param {(err: Error & {type?: 'logic'|'ajax'}) => void} failureCallback - エラー時に呼ばれるコールバック。err.type でエラー種別（logic:入力不備/ajax:API通信・データ不備）を判別。\n * @returns {void}\n * @throws {Error} 引数の型が不正な場合\n * @public\n * @example <caption>支店番号で取得</caption>\n * findBankBranch('0005', '123',\n *   (result) => {\n *     console.log(result.bank_branch_number); // '123'\n *     console.log(result.bank_branch_name);   // '本店'\n *     console.log(result.bank_branch_name_kana); // 'ﾎﾝﾃﾝ'\n *   },\n *   (err) => {\n *     alert(err.message);\n *   }\n * );\n *\n * @example <caption>支店名で取得（部分一致）</caption>\n * findBankBranch('みずほ', '渋谷',\n *   (result) => {\n *     // ...\n *   },\n *   (err) => {\n *     // ...\n *   }\n * );\n *\n * @example <caption>エラー時のコールバック</caption>\n * findBankBranch('', '',\n *   (result) => {},\n *   (err) => {\n *     if (err.type === 'logic') {\n *       alert('入力エラー: ' + err.message);\n *     } else {\n *       alert('APIエラー: ' + err.message);\n *     }\n *   }\n * );\n */\nconst findBankBranch = (bankChar, bankBranchChar, successCallback, failureCallback) => {\n  if (typeof bankChar !== 'string')\n    throw new _fi_FinancialInstitutionError(\n      '銀行番号（4桁）または銀行名（部分一致可）は文字列である必要があります',\n      'logic'\n    );\n  if (typeof bankBranchChar !== 'string')\n    throw new _fi_FinancialInstitutionError(\n      '支店番号（3桁）または支店名（部分一致可）は文字列である必要があります',\n      'logic'\n    );\n  if (typeof successCallback !== 'function')\n    throw new _fi_FinancialInstitutionError(\n      '正常時に呼ばれるコールバックは関数である必要があります',\n      'logic'\n    );\n  if (typeof failureCallback !== 'function')\n    throw new _fi_FinancialInstitutionError(\n      'エラー時に呼ばれるコールバックは関数である必要があります',\n      'logic'\n    );\n  if (bankChar.length === 0 || bankBranchChar.length === 0) {\n    if (failureCallback)\n      failureCallback(\n        new _fi_FinancialInstitutionError(\n          '銀行番号、支店番号、支店名のいずれかが未入力です',\n          'logic'\n        )\n      );\n    return;\n  }\n  const bankCharSbn = _fi_convert_to_single_byte_numbers(bankChar);\n  findBank(\n    bankCharSbn,\n    (bankInfo) => {\n      const bankNumber = bankInfo.bank_number;\n      if (!bankNumber) {\n        if (failureCallback)\n          failureCallback(new _fi_FinancialInstitutionError('銀行番号が未入力です', 'ajax'));\n        return;\n      }\n      const bankBranchCharSbn = Number(_fi_convert_to_single_byte_numbers(bankBranchChar));\n      // 支店番号で検索\n      if (\n        bankBranchCharSbn >= 0 &&\n        bankBranchCharSbn <= Number('9'.repeat(_fi_BRANCH_CODE_LENGTH))\n      ) {\n        const bankBranchNumberTemp = '0'.repeat(_fi_BRANCH_CODE_LENGTH) + String(bankBranchCharSbn);\n        const bankBranchNumber = bankBranchNumberTemp.slice(-_fi_BRANCH_CODE_LENGTH);\n        fetch(\n          _fi_BANK_API_BASE_URL + '/banks/' + bankNumber + '/branches/' + bankBranchNumber + '.json'\n        )\n          .then((response) => {\n            if (!response.ok) {\n              if (response.status === 404) {\n                throw new _fi_FinancialInstitutionError(\n                  `銀行番号「${bankNumber}」支店番号「${bankBranchNumber}」に該当する支店が見つかりません`,\n                  'ajax'\n                );\n              } else if (response.status >= 500) {\n                throw new _fi_FinancialInstitutionError('サーバーエラーが発生しました', 'ajax');\n              } else {\n                throw new _fi_FinancialInstitutionError(`通信エラー（${response.status}）`, 'ajax');\n              }\n            }\n            return response.json();\n          })\n          .then((result) => {\n            _fi_validateBranchResponse(result);\n            successCallback({\n              bank_branch_number: result.code,\n              bank_branch_name: result.normalize.name,\n              bank_branch_name_kana: convertAccountHolderKana(result.kana, false),\n            });\n          })\n          .catch((err) => {\n            if (failureCallback) {\n              // fetch失敗時も「支店が見つかりません」と返す\n              let message = '支店が見つかりません';\n              if (err instanceof _fi_FinancialInstitutionError) {\n                message = err.message;\n              }\n              failureCallback(new _fi_FinancialInstitutionError(message, 'ajax'));\n            }\n          });\n        return;\n      }\n      // 支店名で検索\n      fetch(\n        _fi_BANK_API_BASE_URL +\n          '/banks/' +\n          bankNumber +\n          '/branches/search.json?name=' +\n          encodeURIComponent(bankBranchChar)\n      )\n        .then((response) => {\n          if (!response.ok) {\n            if (response.status === 404) {\n              throw new _fi_FinancialInstitutionError(\n                `銀行番号「${bankNumber}」支店名「${bankBranchChar}」に該当する支店が見つかりません`,\n                'ajax'\n              );\n            } else if (response.status >= 500) {\n              throw new _fi_FinancialInstitutionError('サーバーエラーが発生しました', 'ajax');\n            } else {\n              throw new _fi_FinancialInstitutionError(`通信エラー（${response.status}）`, 'ajax');\n            }\n          }\n          return response.json();\n        })\n        .then((result) => {\n          try {\n            _fi_validateBranchArrayResponse(result);\n          } catch (e) {\n            if (failureCallback) return failureCallback(e);\n            return;\n          }\n          if (result.length === 1) {\n            successCallback({\n              bank_branch_number: result[0].code,\n              bank_branch_name: result[0].normalize.name,\n              bank_branch_name_kana: convertAccountHolderKana(result[0].kana, false),\n            });\n          } else {\n            if (failureCallback)\n              failureCallback(\n                new _fi_FinancialInstitutionError(\n                  `銀行番号「${bankNumber}」支店名「${bankBranchChar}」に該当する支店が複数見つかりました。より詳細な名称で再検索してください。`,\n                  'ajax'\n                )\n              );\n          }\n        })\n        .catch((err) => {\n          if (failureCallback) {\n            if (!(err instanceof _fi_FinancialInstitutionError))\n              err = new _fi_FinancialInstitutionError(\n                err && err.message ? err.message : 'ネットワークエラーまたは不明なエラー',\n                'ajax'\n              );\n            failureCallback(err);\n          }\n        });\n    },\n    (err) => {\n      if (failureCallback) {\n        if (!(err instanceof _fi_FinancialInstitutionError))\n          err = new _fi_FinancialInstitutionError(\n            err && err.message ? err.message : 'ネットワークエラーまたは不明なエラー',\n            'ajax'\n          );\n        failureCallback(err);\n      }\n    }\n  );\n};\n\n/**\n * 銀行口座番号の書式を7桁の半角数字に整形します。\n * @function\n * @param {string} bankAccountChar - 銀行口座番号（全角・漢数字・半角混在可）\n * @returns {string} 7桁の銀行口座番号（先頭ゼロ埋め、半角数字）\n * @throws {Error} 引数が文字列でない場合、未入力の場合、数字以外が含まれる場合\n * @public\n * @example\n *   formatBankAccountNumber('１２３４５'); // => '0001234'\n *   formatBankAccountNumber('五六七八九'); // => '0005678'\n *   formatBankAccountNumber('1234567'); // => '1234567'\n */\nconst formatBankAccountNumber = (bankAccountChar) => {\n  if (typeof bankAccountChar !== 'string')\n    throw new _fi_FinancialInstitutionError('銀行口座番号は文字列である必要があります', 'logic');\n  if (bankAccountChar.length === 0)\n    throw new _fi_FinancialInstitutionError('銀行口座番号が未入力です', 'logic');\n  const singleByte = _fi_convert_to_single_byte_numbers(bankAccountChar);\n  if (!/^[0-9]+$/.test(singleByte)) {\n    throw new _fi_FinancialInstitutionError(\n      '口座番号に数字以外の文字が含まれています',\n      'validation'\n    );\n  }\n  const bankAccountNumberTemp = '0'.repeat(_fi_ACCOUNT_NUMBER_LENGTH) + singleByte;\n  const bankAccountNumber = bankAccountNumberTemp.slice(-_fi_ACCOUNT_NUMBER_LENGTH);\n  return bankAccountNumber;\n};\n\n/**\n * ゆうちょ口座の記号番号・番号から、銀行名・支店名・口座番号等の情報を変換・取得します。\n *\n * kintone API風のコールバック構文（成功・失敗分離）です。\n * @function\n * @param {string} symbolChar - ゆうちょ口座記号（5桁、全角・半角・漢数字混在可）。\n * @param {string} numberChar - ゆうちょ口座番号（最大8桁、全角・半角・漢数字混在可）。\n * @param {(result: {\n *   symbol: string,                  // 変換後の記号（5桁、半角数字）\n *   number: string,                  // 変換後の番号（6～8桁、半角数字）\n *   bank_number: string,             // 銀行番号（ゆうちょは'9900'固定）\n *   bank_name: string,               // 銀行名（'ゆうちょ銀行'固定）\n *   bank_name_kana: string,          // 銀行名カナ（'ﾕｳﾁﾖ'固定）\n *   bank_branch_number: string,      // 支店番号（3桁、半角数字）\n *   bank_branch_name: string,        // 支店名\n *   bank_branch_name_kana: string,   // 支店名カナ\n *   deposit_type: string,            // 預金種別（'普通'または'当座'）\n *   bank_account_number: string      // 7桁の銀行口座番号（半角数字）\n * }) => void} successCallback - 正常時に呼ばれるコールバック。変換結果オブジェクトを受け取る。\n * @param {(err: Error & {type?: 'logic'|'ajax'}) => void} failureCallback - エラー時に呼ばれるコールバック。err.typeでエラー種別（logic:入力不備/ajax:API通信・データ不備）を判別。\n * @returns {void}\n * @throws {Error} 引数の型が不正な場合\n * @public\n * @example <caption>ゆうちょ記号・番号から銀行情報を取得</caption>\n * convertJapanPostAccount('12345', '6789012',\n *   (result) => {\n *     console.log(result.bank_number); // '9900'\n *     console.log(result.bank_name);   // 'ゆうちょ銀行'\n *     console.log(result.bank_branch_number); // '239'または'238'など\n *     console.log(result.bank_account_number); // '6789012'など\n *   },\n *   (err) => {\n *     alert(err.message);\n *   }\n * );\n *\n * @example <caption>入力不備時のエラー</caption>\n * convertJapanPostAccount('', '',\n *   (result) => {},\n *   (err) => {\n *     if (err.type === 'logic') {\n *       alert('入力エラー: ' + err.message);\n *     } else {\n *       alert('APIエラー: ' + err.message);\n *     }\n *   }\n * );\n *\n * @example <caption>API通信エラー時</caption>\n * convertJapanPostAccount('12345', '6789012',\n *   (result) => {},\n *   (err) => {\n *     if (err.type === 'ajax') {\n *       alert('APIエラー: ' + err.message);\n *     }\n *   }\n * );\n */\nconst convertJapanPostAccount = (symbolChar, numberChar, successCallback, failureCallback) => {\n  if (typeof symbolChar !== 'string')\n    throw new _fi_FinancialInstitutionError(\n      'ゆうちょ口座記号（5桁）は文字列である必要があります',\n      'logic'\n    );\n  if (typeof numberChar !== 'string')\n    throw new _fi_FinancialInstitutionError(\n      'ゆうちょ口座番号（最大8桁）は文字列である必要があります',\n      'logic'\n    );\n  if (typeof successCallback !== 'function')\n    throw new _fi_FinancialInstitutionError(\n      '正常時に呼ばれるコールバックは関数である必要があります',\n      'logic'\n    );\n  if (typeof failureCallback !== 'function')\n    throw new _fi_FinancialInstitutionError(\n      'エラー時に呼ばれるコールバックは関数である必要があります',\n      'logic'\n    );\n  if (symbolChar.length === 0 || numberChar.length === 0) {\n    if (failureCallback)\n      failureCallback(\n        new _fi_FinancialInstitutionError('ゆうちょ記号、ゆうちょ番号が未入力です', 'logic')\n      );\n    return;\n  }\n  const symbolCharSbn = _fi_convert_to_single_byte_numbers(symbolChar);\n  if (!/^[0-9]+$/.test(symbolCharSbn)) {\n    if (failureCallback)\n      failureCallback(\n        new _fi_FinancialInstitutionError(\n          'ゆうちょ口座記号に数字以外の文字が含まれています',\n          'validation'\n        )\n      );\n    return;\n  }\n  const symbol = symbolCharSbn.slice(-_fi_JAPAN_POST_SYMBOL_LENGTH);\n  const numberCharSbn = _fi_convert_to_single_byte_numbers(numberChar);\n  if (!/^[0-9]+$/.test(numberCharSbn)) {\n    if (failureCallback)\n      failureCallback(\n        new _fi_FinancialInstitutionError(\n          'ゆうちょ口座番号に数字以外の文字が含まれています',\n          'validation'\n        )\n      );\n    return;\n  }\n  const bankBranchNumberTemp = symbol.substring(1, 3);\n  const depositTypeTemp = symbol.substring(0, 1);\n  let number = null;\n  let bankBranchNumber = null;\n  let depositType = null;\n  let bankAccountNumber = null;\n  switch (depositTypeTemp) {\n    case '0':\n      bankBranchNumber = bankBranchNumberTemp + '9';\n      depositType = '当座';\n      if (numberCharSbn.length <= 6) {\n        const numberTemp = '0'.repeat(6) + numberCharSbn;\n        number = numberTemp.slice(-6);\n        bankAccountNumber = formatBankAccountNumber(number);\n      }\n      break;\n    case '1':\n      bankBranchNumber = bankBranchNumberTemp + '8';\n      depositType = '普通';\n      const numberTemp = '0'.repeat(_fi_JAPAN_POST_NUMBER_MAX_LENGTH) + numberCharSbn;\n      number = numberTemp.slice(-_fi_JAPAN_POST_NUMBER_MAX_LENGTH);\n      bankAccountNumber = number.substring(0, _fi_ACCOUNT_NUMBER_LENGTH);\n      break;\n  }\n  if (number && bankBranchNumber && depositType && bankAccountNumber) {\n    findBankBranch(\n      '9900',\n      bankBranchNumber,\n      (branchInfo) => {\n        if (branchInfo.bank_branch_number) {\n          successCallback({\n            symbol: symbol,\n            number: number,\n            bank_number: '9900',\n            bank_name: 'ゆうちょ銀行',\n            bank_name_kana: 'ﾕｳﾁﾖ',\n            bank_branch_number: branchInfo.bank_branch_number,\n            bank_branch_name: branchInfo.bank_branch_name,\n            bank_branch_name_kana: branchInfo.bank_branch_name_kana,\n            deposit_type: depositType,\n            bank_account_number: bankAccountNumber,\n          });\n        } else {\n          if (failureCallback)\n            failureCallback(\n              new _fi_FinancialInstitutionError(\n                'ゆうちょ記号からゆうちょ支店情報に変換できませんでした',\n                'ajax'\n              )\n            );\n          return;\n        }\n      },\n      (err) => {\n        if (failureCallback) {\n          if (!(err instanceof _fi_FinancialInstitutionError))\n            err = new _fi_FinancialInstitutionError(\n              err && err.message ? err.message : 'ゆうちょ記号・番号の変換ができませんでした',\n              'ajax'\n            );\n          failureCallback(err);\n        }\n        return;\n      }\n    );\n  } else {\n    if (failureCallback)\n      failureCallback(\n        new _fi_FinancialInstitutionError('ゆうちょ記号・番号の変換ができませんでした', 'logic')\n      );\n    return;\n  }\n};\n\n/**\n * 口座名義人を全銀手順に準拠した半角カナ（および略語）に変換します。\n * @function\n * @param {string} inputStr - 変換対象の口座名義人（全角・半角・記号・漢字混在可）。\n * @param {boolean} [acronymSw=true] - 法人・営業所・事業名の略語変換を行うか（true:略語化あり/false:略語化なし）。\n * @returns {string} 半角カナ・略語化済みの口座名義人（全銀手順で許可される文字のみ）。\n * @throws {Error} 引数が文字列でない場合、未入力の場合、全銀手順で許可されない文字が含まれる場合。\n * @public\n * @example <caption>通常の変換</caption>\n * convertAccountHolderKana('株式会社山田太郎'); // => 'ｶ)ﾔﾏﾀﾞﾀﾛｳ'\n *\n * @example <caption>略語化なし</caption>\n * convertAccountHolderKana('株式会社山田太郎', false); // => 'ｶﾌﾞｼｷｶﾞｲｼﾔﾔﾏﾀﾞﾀﾛｳ'\n *\n * @example <caption>全銀手順で許可されない文字が含まれる場合</caption>\n * try {\n *   convertAccountHolderKana('山田太郎😊');\n * } catch (e) {\n *   alert(e.message); // => '全銀手順の口座名義人として利用できない文字が含まれています'\n * }\n */\nconst convertAccountHolderKana = (inputStr, acronymSw = true) => {\n  if (typeof inputStr !== 'string')\n    throw new _fi_FinancialInstitutionError('口座名義人は文字列である必要があります', 'logic');\n  if (inputStr.length === 0)\n    throw new _fi_FinancialInstitutionError('口座名義人が未入力です', 'logic');\n  const _fi_acronym_replace = (targetStr, list, regexpChar, positionSw) => {\n    if (targetStr) {\n      const charSearch = targetStr.search(regexpChar);\n      if (charSearch !== -1) {\n        let parenthesisPosition = 0;\n        if (positionSw) {\n          if (charSearch === 0) {\n            parenthesisPosition = 1;\n          } else {\n            const charMatch = targetStr.match(regexpChar);\n            if (targetStr.length === charSearch + charMatch[0].length) {\n              parenthesisPosition = 2;\n            } else {\n              parenthesisPosition = 3;\n            }\n          }\n        }\n        return targetStr.replace(regexpChar, (char) => {\n          switch (parenthesisPosition) {\n            case 1:\n              return list[char] + ')';\n            case 2:\n              return '(' + list[char];\n            case 3:\n              return '(' + list[char] + ')';\n            default:\n              return list[char];\n          }\n        });\n      } else {\n        return targetStr;\n      }\n    }\n  };\n  const inputSbc = _fi_convert_to_single_byte_characters(inputStr);\n  const bankKana = inputSbc.replace(_fi_BANK_KANA_LIST_REG, (c) => _fi_BANK_KANA_LIST[c]);\n  let acronym = bankKana;\n  if (acronymSw) {\n    for (let c = 0; c < 3; c++) {\n      let list = {};\n      let regexpChar = '';\n      let positionSw = true;\n      switch (c) {\n        case 0:\n          list = _fi_CORPORATE_ABBREVIATIONS_LIST;\n          regexpChar = _fi_CORPORATE_ABBREVIATIONS_LIST_REG;\n          break;\n        case 1:\n          list = _fi_SALES_OFFICES_LIST;\n          regexpChar = _fi_SALES_OFFICES_LIST_REG;\n          break;\n        case 2:\n          list = _fi_BUSINESS_LIST;\n          regexpChar = _fi_BUSINESS_LIST_REG;\n          positionSw = false;\n          break;\n      }\n      acronym = _fi_acronym_replace(acronym, list, regexpChar, positionSw);\n    }\n  }\n  const acronymRegexp = /^[()\\-,./0-9A-Zｦ-ﾟ\\s]+$/;\n  if (!acronymRegexp.test(acronym)) {\n    throw new _fi_FinancialInstitutionError(\n      '全銀手順の口座名義人として利用できない文字が含まれています',\n      'validation'\n    );\n  }\n  return acronym;\n};\n\n/**\n * 振込指定日が有効かどうかを判定する非同期関数（コールバック型）。\n * @function\n * @param {string} designateTransferDate - 振込指定日（ISO形式: 'YYYY-MM-DD' など）。\n * @param {boolean} todaySw - 日付限定スイッチ（true:今日以降14日以内かつ平日・営業日かを判定/false:日付範囲判定なし）。\n * @param {(isValid: boolean) => void} callback - 判定結果（有効:true/無効:false）を返すコールバック関数。\n * @returns {void}\n * @throws {Error} 引数の型が不正な場合。\n * @public\n * @description\n * - todaySw=trueの場合、今日（18時以降は翌日扱い）から14日以内かつ平日・営業日（祝日・年末年始（12/31～1/3）除く）かを判定します。\n * - todaySw=falseの場合は、曜日・祝日・年末年始（12/31～1/3）のみ判定します。\n *\n * @example <caption>通常の利用例</caption>\n * isValidTransferDate('2025-09-15', true, (isValid) => {\n *   if (isValid) {\n *     alert('指定日は有効です');\n *   } else {\n *     alert('指定日は無効です');\n *   }\n * });\n *\n * @example <caption>型不正時の例外</caption>\n * try {\n *   isValidTransferDate(20250915, true, () => {});\n * } catch (e) {\n *   alert(e.message); // => '振込指定日は文字列である必要があります'\n * }\n */\nconst isValidTransferDate = (designateTransferDate, todaySw = false, callback) => {\n  if (typeof designateTransferDate !== 'string')\n    throw new _fi_FinancialInstitutionError('振込指定日は文字列である必要があります', 'logic');\n  if (typeof todaySw !== 'boolean')\n    throw new _fi_FinancialInstitutionError(\n      '日付限定スイッチはboolean型である必要があります',\n      'logic'\n    );\n  if (typeof callback !== 'function')\n    throw new _fi_FinancialInstitutionError('コールバックは関数である必要があります', 'logic');\n  if (designateTransferDate.length === 0) return callback(false);\n  let now = new Date();\n  let checkFlag = true;\n  // ISO日付文字列をDateに変換\n  const checkDate = new Date(designateTransferDate);\n  if (isNaN(checkDate.getTime())) return callback(false);\n\n  // 今日の判定\n  const _fi_process = (skipHolidayCb) => {\n    if (todaySw) {\n      let today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n      // 18時以降は翌日扱い\n      if (now.getHours() >= _fi_CUTOFF_HOUR_FOR_NEXT_DAY) {\n        today.setDate(today.getDate() + 1);\n      }\n      // 祝日をスキップ\n      const _fi_skipHoliday = (date, cb) => {\n        const ymd = date.toISOString().slice(0, 10);\n        _fi_getNationalHolidayName(ymd, (name) => {\n          if (name) {\n            date.setDate(date.getDate() + 1);\n            _fi_skipHoliday(date, cb);\n          } else {\n            cb(date);\n          }\n        });\n      };\n      _fi_skipHoliday(today, (validToday) => {\n        // checkDateとtodayの差（日数）\n        const diffDays = Math.floor((checkDate - validToday) / (1000 * 60 * 60 * 24));\n        if (diffDays < _fi_TRANSFER_DATE_MIN_DAYS || diffDays >= _fi_TRANSFER_DATE_MAX_DAYS) {\n          checkFlag = false;\n        }\n        skipHolidayCb();\n      });\n    } else {\n      skipHolidayCb();\n    }\n  };\n\n  // 曜日・祝日・年末年始判定\n  _fi_process(() => {\n    const weekday = checkDate.getDay();\n    if (weekday === _fi_SUNDAY || weekday === _fi_SATURDAY) {\n      checkFlag = false;\n    }\n    const ymd = checkDate.toISOString().slice(0, 10);\n    _fi_getNationalHolidayName(ymd, (name) => {\n      if (name) {\n        checkFlag = false;\n      }\n      // 1/1～1/3は不可\n      if (checkDate.getMonth() === _fi_JANUARY && _fi_NEW_YEAR_DAYS.includes(checkDate.getDate())) {\n        checkFlag = false;\n      }\n      // 12/31は不可\n      if (checkDate.getMonth() === _fi_DECEMBER && checkDate.getDate() === _fi_NEW_YEAR_EVE) {\n        checkFlag = false;\n      }\n      callback(checkFlag);\n    });\n  });\n};\n\n/**\n * 文字列のバイト数（全銀手順基準）を計算します。\n * @function\n * @param {string} inputStr - バイト数計算対象の文字列（全角・半角・記号・漢字混在可）。\n * @returns {number} バイト数（ASCII・半角カナは1バイト、全角カナ・漢字等は2バイト）。\n * @throws {Error} 引数が文字列でない場合、未入力の場合、全銀手順で許可されない文字が含まれる場合。\n * @public\n * @example <caption>通常の利用例</caption>\n * getByteLength('ﾀﾛｳ'); // => 3\n * getByteLength('タロウ'); // => 6\n * getByteLength('山田太郎'); // => 8\n *\n * @example <caption>全銀手順で許可されない文字が含まれる場合</caption>\n * try {\n *   getByteLength('山田😊');\n * } catch (e) {\n *   alert(e.message); // => '全銀手順で許可されない文字が含まれています'\n * }\n */\nconst getByteLength = (inputStr) => {\n  if (typeof inputStr !== 'string')\n    throw new _fi_FinancialInstitutionError(\n      'バイト数計算対象の文字列は文字列である必要があります',\n      'logic'\n    );\n  if (inputStr.length === 0)\n    throw new _fi_FinancialInstitutionError('バイト数計算対象の文字列が未入力です', 'logic');\n  if (!_fi_is_zengin_allowed_chars(inputStr))\n    throw new _fi_FinancialInstitutionError(\n      '全銀手順で許可されない文字が含まれています',\n      'validation'\n    );\n  let bytes = 0;\n  for (let c = 0; c < inputStr.length; c++) {\n    const code = inputStr.charCodeAt(c);\n    // ASCII・半角カナは1バイト\n    if (\n      (code >= 0x00 && code <= 0x7f) || // ASCII\n      (code >= 0xff61 && code <= 0xff9f) // 半角カナ\n    ) {\n      bytes += 1;\n    } else {\n      // それ以外（全角カナ・漢字など）は2バイト\n      bytes += 2;\n    }\n  }\n  return bytes;\n};\n\n/**\n * 文字列を指定したバイト数で切り取る関数（マルチバイト・全銀手順対応）。\n * @function\n * @param {string} inputStr - 切り取り対象の文字列（全角・半角・記号・漢字混在可）。\n * @param {number} byteLength - 切り取りたいバイト数（1以上の整数）。\n * @returns {string} 指定バイト数で切り取った文字列（バイト数超過部分は切り捨て）。\n * @throws {Error} 引数が不正な場合（文字列でない、未入力、バイト数が1未満など）。\n * @public\n * @example <caption>通常の利用例</caption>\n * sliceByByteLength('山田太郎', 6); // => '山田太'\n * sliceByByteLength('ﾀﾛｳ', 2); // => 'ﾀﾛ'\n * sliceByByteLength('タロウ', 4); // => 'タロ'\n *\n * @example <caption>バイト数が1未満の場合</caption>\n * try {\n *   sliceByByteLength('山田太郎', 0);\n * } catch (e) {\n *   alert(e.message); // => '切り取りバイト数が不正です'\n * }\n */\nconst sliceByByteLength = (inputStr, byteLength) => {\n  if (typeof inputStr !== 'string')\n    throw new _fi_FinancialInstitutionError(\n      'バイト数で切り取りたい文字列は文字列である必要があります',\n      'logic'\n    );\n  if (typeof byteLength !== 'number')\n    throw new _fi_FinancialInstitutionError(\n      '切り取りたいバイト数は数値である必要があります',\n      'logic'\n    );\n  if (inputStr.length === 0)\n    throw new _fi_FinancialInstitutionError('バイト数で切り取りたい文字列が未入力です', 'logic');\n  if (byteLength < 1)\n    throw new _fi_FinancialInstitutionError('切り取りバイト数が不正です', 'logic');\n  let result = '';\n  let length = 0;\n  for (let charSlice of inputStr) {\n    const charSliceByte = getByteLength(charSlice);\n    if (length + charSliceByte > byteLength) break;\n    result += charSlice;\n    length += charSliceByte;\n  }\n  return result;\n};\n\n// 公開\nif (typeof window !== 'undefined') {\n  window.convertAccountHolderKana = convertAccountHolderKana;\n  window.getByteLength = getByteLength;\n  window.sliceByByteLength = sliceByByteLength;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/issiki_sigeo/Library/CloudStorage/OneDrive-公益社団法人神奈川県社会福祉士会/ドキュメント/kintone/アプリ開発/my-first-static-web-app/src/jquery.autoKana.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'start' is defined but never used.","line":55,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":55,"endColumn":19,"suggestions":[{"messageId":"removeVar","data":{"varName":"start"},"fix":{"range":[1927,1972],"text":""},"desc":"Remove unused variable 'start'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'stop' is defined but never used.","line":59,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":59,"endColumn":18,"suggestions":[{"messageId":"removeVar","data":{"varName":"stop"},"fix":{"range":[1978,2023],"text":""},"desc":"Remove unused variable 'stop'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'toggle' is defined but never used.","line":63,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":63,"endColumn":20,"suggestions":[{"messageId":"removeVar","data":{"varName":"toggle"},"fix":{"range":[2029,2308],"text":""},"desc":"Remove unused variable 'toggle'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'ev' is assigned a value but never used.","line":64,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":64,"endColumn":13,"suggestions":[{"messageId":"removeVar","data":{"varName":"ev"},"fix":{"range":[2060,2091],"text":""},"desc":"Remove unused variable 'ev'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":119,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":119,"endColumn":30,"suggestions":[{"messageId":"removeVar","data":{"varName":"event"},"fix":{"range":[3532,3537],"text":""},"desc":"Remove unused variable 'event'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":122,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":122,"endColumn":31,"suggestions":[{"messageId":"removeVar","data":{"varName":"event"},"fix":{"range":[3596,3601],"text":""},"desc":"Remove unused variable 'event'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'event' is defined but never used. Allowed unused args must match /^_/u.","line":126,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":126,"endColumn":33,"suggestions":[{"messageId":"removeVar","data":{"varName":"event"},"fix":{"range":[3681,3686],"text":""},"desc":"Remove unused variable 'event'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'self' is assigned a value but never used.","line":150,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":150,"endColumn":15,"suggestions":[{"messageId":"removeVar","data":{"varName":"self"},"fix":{"range":[4404,4420],"text":""},"desc":"Remove unused variable 'self'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Copyright (c) 2013 Keith Perhac @ DelfiNet (http://delfi-net.com)\n//\n// Based on the AutoRuby library created by:\n// Copyright (c) 2005-2008 spinelz.org (http://script.spinelz.org/)\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n(function ($) {\n  $.fn.autoKana = function (element1, element2, passedOptions) {\n    var options = $.extend(\n      {\n        katakana: false,\n      },\n      passedOptions\n    );\n\n    var kana_extraction_pattern = new RegExp('[^ 　ぁあ-んー]', 'g');\n    var kana_compacting_pattern = new RegExp('[ぁぃぅぇぉっゃゅょ]', 'g');\n    var elName,\n      elKana,\n      active = false,\n      timer = null,\n      flagConvert = true,\n      input,\n      values,\n      ignoreString,\n      baseKana;\n\n    elName = $(element1);\n    elKana = $(element2);\n    active = true;\n    _stateClear();\n\n    elName.blur(_eventBlur);\n    elName.focus(_eventFocus);\n    elName.keydown(_eventKeyDown);\n\n    function start() {\n      active = true;\n    }\n\n    function stop() {\n      active = false;\n    }\n\n    function toggle(event) {\n      var ev = event || window.event;\n      if (event) {\n        var el = Event.element(event);\n        if (el.checked) {\n          active = true;\n        } else {\n          active = false;\n        }\n      } else {\n        active = !active;\n      }\n    }\n\n    function _checkConvert(new_values) {\n      if (!flagConvert) {\n        if (Math.abs(values.length - new_values.length) > 1) {\n          var tmp_values = new_values.join('').replace(kana_compacting_pattern, '').split('');\n          if (Math.abs(values.length - tmp_values.length) > 1) {\n            _stateConvert();\n          }\n        } else {\n          if (values.length == input.length && values.join('') != input) {\n            if (input.match(kana_extraction_pattern)) {\n              _stateConvert();\n            }\n          }\n        }\n      }\n    }\n\n    function _checkValue() {\n      var new_input, new_values;\n      new_input = elName.val();\n      if (new_input == '' && elKana.val() != '') {\n        _stateClear();\n        _setKana();\n      } else {\n        new_input = _removeString(new_input);\n        if (input == new_input) {\n          return;\n        } else {\n          input = new_input;\n          if (!flagConvert) {\n            new_values = new_input.replace(kana_extraction_pattern, '').split('');\n            _checkConvert(new_values);\n            _setKana(new_values);\n          }\n        }\n      }\n    }\n\n    function _clearInterval() {\n      clearInterval(timer);\n    }\n\n    function _eventBlur(event) {\n      _clearInterval();\n    }\n    function _eventFocus(event) {\n      _stateInput();\n      _setInterval();\n    }\n    function _eventKeyDown(event) {\n      if (flagConvert) {\n        _stateInput();\n      }\n    }\n    function _isHiragana(chara) {\n      return (chara >= 12353 && chara <= 12435) || chara == 12445 || chara == 12446;\n    }\n    function _removeString(new_input) {\n      if (new_input.indexOf(ignoreString) !== -1) {\n        return new_input.replace(ignoreString, '');\n      } else {\n        var i, ignoreArray, inputArray;\n        ignoreArray = ignoreString.split('');\n        inputArray = new_input.split('');\n        for (i = 0; i < ignoreArray.length; i++) {\n          if (ignoreArray[i] == inputArray[i]) {\n            inputArray[i] = '';\n          }\n        }\n        return inputArray.join('');\n      }\n    }\n    function _setInterval() {\n      var self = this;\n      timer = setInterval(_checkValue, 30);\n    }\n    function _setKana(new_values) {\n      if (!flagConvert) {\n        if (new_values) {\n          values = new_values;\n        }\n        if (active) {\n          var _val = _toKatakana(baseKana + values.join(''));\n          elKana.val(_val).change();\n        }\n      }\n    }\n    function _stateClear() {\n      baseKana = '';\n      flagConvert = false;\n      ignoreString = '';\n      input = '';\n      values = [];\n    }\n    function _stateInput() {\n      baseKana = elKana.val();\n      flagConvert = false;\n      ignoreString = elName.val();\n    }\n    function _stateConvert() {\n      baseKana = baseKana + values.join('');\n      flagConvert = true;\n      values = [];\n    }\n    function _toKatakana(src) {\n      if (options.katakana) {\n        var c, i, str;\n        str = new String();\n        for (i = 0; i < src.length; i++) {\n          c = src.charCodeAt(i);\n          if (_isHiragana(c)) {\n            str += String.fromCharCode(c + 96);\n          } else {\n            str += src.charAt(i);\n          }\n        }\n        return str;\n      } else {\n        return src;\n      }\n    }\n  };\n})(jQuery);\n","usedDeprecatedRules":[]},{"filePath":"/Users/issiki_sigeo/Library/CloudStorage/OneDrive-公益社団法人神奈川県社会福祉士会/ドキュメント/kintone/アプリ開発/my-first-static-web-app/src/kintone-custom-lib.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":54,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":54,"endColumn":17},{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":96,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":96,"endColumn":21},{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":105,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":105,"endColumn":25},{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":117,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":117,"endColumn":19},{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":260,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":260,"endColumn":23},{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":540,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":540,"endColumn":19},{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":566,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":566,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** kintone内でよく使われる処理をまとめたJavaScriptの関数群です。\n * @author Shigeo Isshiki <issiki@kacsw.or.jp>\n * @version 1.0.0\n */\n// 関数命名ルール: 外部に見せる関数名はそのまま、内部で使用する関数名は(_kc_)で始める\n/* exported notifyError, getFieldValueOr, kintoneEventOn, notifyInfo, notifyWarning, setRecordValues, setSpaceFieldButton, setSpaceFieldText */\n\n// 共通定数\n/**\n * ダイアログ表示の際に使用するアイコンが格納されている URLのベースパス\n * @constant {string} _KC_ASSET_BASE - アイコン画像のベースURL\n */\nconst _KC_ASSET_BASE = 'https://js.kacsw.or.jp/image';\n\n// 内部関数\n/**\n * HTML文字列をサニタイズして安全な HTML を返します。\n * - フォールバックとして script 要素や on* 属性、javascript: URL を除去します。\n * - 最終的に失敗した場合はエスケープしたプレーンテキストを返します。\n *\n * @param {string} html サニタイズ対象の HTML 文字列（null/非文字列でも許容し String() で扱います）\n * @returns {string} サニタイズ済の HTML 文字列\n */\nconst _kc_sanitizeHtml = (html) => {\n  // フォールバック: 単純なサニタイズ（スクリプトタグ除去・on* 属性除去）\n  // 完全な保護を約束するものではありません\n  try {\n    const template = document.createElement('template');\n    template.innerHTML = html;\n    // remove script elements\n    const scripts = template.content.querySelectorAll('script');\n    scripts.forEach((s) => s.remove());\n    // remove on* attributes\n    const walker = document.createTreeWalker(\n      template.content,\n      NodeFilter.SHOW_ELEMENT,\n      null,\n      false\n    );\n    let node = walker.nextNode();\n    while (node) {\n      [...node.attributes].forEach((attr) => {\n        if (/^on/i.test(attr.name)) {\n          node.removeAttribute(attr.name);\n        }\n        // javascript: URL を除去\n        if (/^href$|^src$/i.test(attr.name) && /javascript:\\s*/i.test(attr.value)) {\n          node.removeAttribute(attr.name);\n        }\n      });\n      node = walker.nextNode();\n    }\n    return template.innerHTML;\n  } catch (error) {\n    // 最後の手段: プレーンテキストにして挿入\n    const tmp = document.createElement('div');\n    tmp.textContent = html;\n    return tmp.innerHTML;\n  }\n};\n\n/**\n * 内部: ダイアログ作成＆表示の共通ロジック\n * options: {\n *   title: string,\n *   body: HTMLElement,\n * }\n */\nconst _kc_showDialog = (options) => {\n  if (!options || typeof options !== 'object') return;\n  const { title, body } = options;\n  const config = {\n    title: String(title || ''),\n    body: body,\n    showOkButton: true,\n    okButtonText: '閉じる',\n    showCancelButton: false,\n    cancelButtonText: '',\n    showCloseButton: false,\n    beforeClose: () => {\n      return;\n    },\n  };\n\n  try {\n    const dialog = kintone.createDialog && kintone.createDialog(config);\n    const setOkAriaLabel = (dialogObj) => {\n      try {\n        const container = dialogObj.element || dialogObj.dialog || dialogObj.container || null;\n        if (container) {\n          const okBtn = container.querySelector('button.kintone-dialog-ok-button, button');\n          if (okBtn) {\n            okBtn.setAttribute('aria-label', '閉じる');\n          }\n        }\n      } catch (error) {\n        // noop\n      }\n    };\n    if (dialog && typeof dialog.then === 'function') {\n      dialog\n        .then((object) => {\n          try {\n            object.show();\n          } catch (error) {}\n          setOkAriaLabel(object);\n        })\n        .catch((error) => console.error('ダイアログ表示中にエラー:', error));\n    } else if (dialog && typeof dialog.show === 'function') {\n      dialog.show();\n      setOkAriaLabel(dialog);\n    }\n  } catch (error) {\n    console.error('_kc_showDialog error', error);\n    try {\n      alert(body && body.textContent ? body.textContent : String(title));\n    } catch (error) {\n      /* noop */\n    }\n  }\n};\n\n// 公開: kintone 側から直接呼び出すためにグローバルに割り当てる\nif (typeof window !== 'undefined') {\n  window.notifyError = notifyError;\n  window.getFieldValueOr = getFieldValueOr;\n  window.kintoneEventOn = kintoneEventOn;\n  window.notifyInfo = notifyInfo;\n  window.notifyWarning = notifyWarning;\n  window.setRecordValues = setRecordValues;\n  window.setSpaceFieldButton = setSpaceFieldButton;\n  window.setSpaceFieldText = setSpaceFieldText;\n}\n\n// ここから外部に公開する関数群\n/**\n * エラーをユーザーに通知するダイアログを表示します。\n * - kintone.createDialog を使ってカスタムダイアログを表示します。\n * - allowHtml が true のときのみ message を HTML として挿入（サニタイズあり）、\n *   デフォルトはプレーンテキストとして表示します。\n * - notifyInfo/notifyWarning と同様に共通ロジックを利用します。\n *\n * @param {string|Node} message 表示するメッセージ（文字列が想定）。Node を渡す場合はそのまま挿入されます。\n * @param {string} [title='エラー'] ダイアログのタイトル\n * @param {boolean} [allowHtml=false] メッセージを HTML として挿入するか（サニタイズされます）\n * @returns {void}\n */\nconst notifyError = (message, title = 'エラー', allowHtml = false) => {\n  const body = document.createElement('div');\n  // class 名を付与してスタイルやテストを容易にする\n  body.className = 'kc-notify-error';\n  // アクセシビリティ: アラートダイアログとして扱う\n  body.setAttribute('role', 'alertdialog');\n  body.style.display = 'flex';\n  body.style.alignItems = 'center';\n  body.style.gap = '1em';\n  body.style.margin = '1em';\n  const errorImage = document.createElement('img');\n  errorImage.src = _KC_ASSET_BASE + '/error-icon.png';\n  errorImage.alt = 'エラーアイコン';\n  errorImage.style.width = '32px';\n  errorImage.style.height = '32px';\n  // 装飾的な画像はスクリーンリーダーから隠す\n  errorImage.setAttribute('aria-hidden', 'true');\n  body.appendChild(errorImage);\n  const errorText = document.createElement('div');\n  // 読み上げ優先度: 即時読み上げが望ましいため assertive に設定\n  errorText.setAttribute('role', 'status');\n  errorText.setAttribute('aria-live', 'assertive');\n  errorText.className = 'kc-notify-error__message';\n  // 参照用 id を付与して dialog に関連付けられるようにする\n  const messageId = 'kc-notify-error__message-' + Math.random().toString(36).slice(2, 8);\n  errorText.id = messageId;\n  if (allowHtml) {\n    // HTML を許可する場合のみサニタイズ済の HTML を挿入\n    errorText.innerHTML = _kc_sanitizeHtml(message);\n  } else {\n    // デフォルトはプレーンテキストとして表示（XSS リスク低減）\n    errorText.textContent = String(message);\n  }\n  body.appendChild(errorText);\n  // ダイアログにタイトルをラベルとして与える。aria-describedby で本文を参照。\n  body.setAttribute('aria-label', String(title));\n  body.setAttribute('aria-describedby', messageId);\n  // 共通処理でダイアログ表示\n  _kc_showDialog({ title, body });\n};\n\n/**\n * getFieldValueOr - record から指定フィールドの value を安全に取得します。\n * - record が null/非オブジェクト、fieldCode が文字列でない場合は defaultValue を返します。\n * - 指定フィールドが存在しない、または value が undefined の場合は defaultValue を返します。\n * - defaultValue を省略した場合は undefined が返ります。\n *\n * @param {Object} record kintone の record オブジェクト想定\n * @param {string} fieldCode 取得するフィールドのフィールドコード\n * @param {*} [defaultValue] フィールドが無ければ返す既定値（省略可能）\n * @returns {*} フィールドの value または defaultValue\n */\nconst getFieldValueOr = (record, fieldCode, defaultValue) => {\n  try {\n    if (typeof fieldCode !== 'string' || !fieldCode.trim()) {\n      console.warn('getFieldValueOr: invalid fieldCode', { fieldCode });\n      return defaultValue;\n    }\n    if (typeof record !== 'object' || record === null || Array.isArray(record)) {\n      console.warn('getFieldValueOr: invalid record', { record });\n      return defaultValue;\n    }\n    const field = Object.prototype.hasOwnProperty.call(record, fieldCode)\n      ? record[fieldCode]\n      : undefined;\n    if (!field || typeof field !== 'object') {\n      return defaultValue;\n    }\n    // value が存在する場合はそのまま返す（null や空文字も有効値として返す）\n    if (Object.prototype.hasOwnProperty.call(field, 'value')) {\n      return field.value;\n    }\n    return defaultValue;\n  } catch (error) {\n    console.error('getFieldValueOr: unexpected error', {\n      error,\n      record,\n      fieldCode,\n    });\n    return defaultValue;\n  }\n};\n\n/**\n * kintoneEventOn - kintone のイベント登録ラッパー\n * - 引数チェックを行い、登録成功で true、失敗で false を返します。\n * @param {string|string[]} events イベント名またはイベント名配列\n * @param {function} handler イベントハンドラ関数\n * @returns {boolean} 登録に成功したら true、入力が不正な場合は false\n */\nconst kintoneEventOn = (events, handler) => {\n  // basic validation\n  const isValidEvents =\n    typeof events === 'string' ||\n    (Array.isArray(events) && events.every((e) => typeof e === 'string'));\n  if (!isValidEvents || typeof handler !== 'function') {\n    console.warn('kintoneEventOn: invalid arguments', { events, handler });\n    return false;\n  }\n\n  try {\n    kintone.events.on(events, (event) => {\n      try {\n        return handler(event);\n      } catch (error) {\n        console.error('kintone event handler error', { events, error });\n        try {\n          notifyError(\n            'システムエラーが発生しました。詳細はコンソールを確認してください。',\n            undefined,\n            true\n          );\n        } catch (error) {}\n        return event;\n      }\n    });\n    return true;\n  } catch (error) {\n    console.error('kintoneEventOn: failed to register events', {\n      events,\n      error,\n    });\n    return false;\n  }\n};\n\n/**\n * 情報をユーザーに通知するダイアログを表示します。\n * - kintone.createDialog を使ってカスタムダイアログを表示します。\n * - allowHtml が true のときのみ message を HTML として挿入（サニタイズあり）、\n *   デフォルトはプレーンテキストとして表示します。\n * - notifyError/notifyWarning と同様に共通ロジックを利用します。\n *\n * @param {string|Node} message 表示するメッセージ（文字列が想定）。Node を渡す場合はそのまま挿入されます。\n * @param {string} [title='情報'] ダイアログのタイトル\n * @param {boolean} [allowHtml=false] メッセージを HTML として挿入するか（サニタイズされます）\n * @returns {void}\n */\nconst notifyInfo = (message, title = '情報', allowHtml = false) => {\n  const body = document.createElement('div');\n  body.className = 'kc-notify-info';\n  body.setAttribute('role', 'alertdialog');\n  body.style.display = 'flex';\n  body.style.alignItems = 'center';\n  body.style.gap = '1em';\n  body.style.margin = '1em';\n\n  const infoImage = document.createElement('img');\n  infoImage.src = _KC_ASSET_BASE + '/info-icon.png';\n  infoImage.alt = '情報アイコン';\n  infoImage.style.width = '32px';\n  infoImage.style.height = '32px';\n  infoImage.setAttribute('aria-hidden', 'true');\n  body.appendChild(infoImage);\n\n  const infoText = document.createElement('div');\n  infoText.setAttribute('role', 'status');\n  infoText.setAttribute('aria-live', 'polite');\n  infoText.className = 'kc-notify-info__message';\n  const messageId = 'kc-notify-info__message-' + Math.random().toString(36).slice(2, 8);\n  infoText.id = messageId;\n  if (allowHtml) {\n    infoText.innerHTML = _kc_sanitizeHtml(message);\n  } else {\n    infoText.textContent = String(message);\n  }\n  body.appendChild(infoText);\n  body.setAttribute('aria-label', String(title));\n  body.setAttribute('aria-describedby', messageId);\n\n  _kc_showDialog({ title, body });\n};\n\n/**\n * 注意をユーザーに通知するダイアログを表示します。\n * - kintone.createDialog を使ってカスタムダイアログを表示します。\n * - allowHtml が true のときのみ message を HTML として挿入（サニタイズあり）、\n *   デフォルトはプレーンテキストとして表示します。\n * - notifyError/notifyWarning と同様に共通ロジックを利用します。\n *\n * @param {string|Node} message 表示するメッセージ（文字列が想定）。Node を渡す場合はそのまま挿入されます。\n * @param {string} [title='注意'] ダイアログのタイトル\n * @param {boolean} [allowHtml=false] メッセージを HTML として挿入するか（サニタイズされます）\n * @returns {void}\n */\nconst notifyWarning = (message, title = '注意', allowHtml = false) => {\n  const body = document.createElement('div');\n  body.className = 'kc-notify-warning';\n  body.setAttribute('role', 'alertdialog');\n  body.style.display = 'flex';\n  body.style.alignItems = 'center';\n  body.style.gap = '1em';\n  body.style.margin = '1em';\n\n  const warnImage = document.createElement('img');\n  warnImage.src = _KC_ASSET_BASE + '/warning-icon.png';\n  warnImage.alt = '注意アイコン';\n  warnImage.style.width = '32px';\n  warnImage.style.height = '32px';\n  warnImage.setAttribute('aria-hidden', 'true');\n  body.appendChild(warnImage);\n\n  const warnText = document.createElement('div');\n  warnText.setAttribute('role', 'status');\n  warnText.setAttribute('aria-live', 'polite');\n  warnText.className = 'kc-notify-warning__message';\n  const messageId = 'kc-notify-warning__message-' + Math.random().toString(36).slice(2, 8);\n  warnText.id = messageId;\n  if (allowHtml) {\n    warnText.innerHTML = _kc_sanitizeHtml(message);\n  } else {\n    warnText.textContent = String(message);\n  }\n  body.appendChild(warnText);\n  body.setAttribute('aria-label', String(title));\n  body.setAttribute('aria-describedby', messageId);\n  // 共通処理でダイアログ表示\n  _kc_showDialog({ title, body });\n};\n\n/**\n * setRecordValues - record の複数フィールドに対して値を一括設定するユーティリティ\n * - 引数チェックを行い、成功時は true、失敗時は false を返します。\n * @param {Object} record 各フィールドの値（kintone の record オブジェクト想定）\n * @param {Object} values 設定するフィールド値のオブジェクト（キーがフィールドコード、値が設定値）\n * @returns {boolean} 成功したら true、入力が不正な場合は false\n */\nconst setRecordValues = (record, values) => {\n  if (\n    typeof record !== 'object' ||\n    record === null ||\n    Array.isArray(record) ||\n    typeof values !== 'object' ||\n    values === null\n  ) {\n    console.warn('setRecordValues: invalid arguments', { record, values });\n    return false;\n  }\n  Object.keys(values).forEach((k) => {\n    // 既存フィールドがある場合は value に設定する（kintone フィールドオブジェクト想定）\n    if (Object.prototype.hasOwnProperty.call(record, k)) {\n      const fieldObj = record[k];\n      if (fieldObj && typeof fieldObj === 'object') {\n        if (Object.prototype.hasOwnProperty.call(fieldObj, 'value')) {\n          fieldObj.value = values[k];\n        } else {\n          // オブジェクトだが value プロパティが無い場合は value を追加する\n          fieldObj.value = values[k];\n        }\n      } else {\n        // 原始値が入っている場合は上書き\n        record[k] = values[k];\n      }\n    } else {\n      // フィールドが存在しない場合は簡易フィールドオブジェクトを作成して value を設定する\n      record[k] = { value: values[k] };\n    }\n  });\n  return true;\n};\n\n/**\n * kintone のスペースフィールド（スペースエレメント）を表示/非表示に切り替えます。\n *\n * @param {string} spaceField スペースフィールドのフィールドコード\n * @param {boolean} display true=表示, false=非表示\n * @returns {boolean} 成功したら true、引数不正や要素が見つからなければ false\n */\nconst setSpaceFieldDisplay = (spaceField, display) => {\n  if (typeof spaceField !== 'string' || !spaceField.trim() || typeof display !== 'boolean') {\n    console.warn('setSpaceFieldDisplay: invalid arguments', {\n      spaceField,\n      display,\n    });\n    return false;\n  }\n  const spaceElement = kintone.app.record.getSpaceElement(spaceField);\n  if (!spaceElement) {\n    console.warn('setSpaceFieldDisplay: space element not found', spaceField);\n    return false;\n  }\n  spaceElement.parentNode.style.display = display ? '' : 'none';\n  return true;\n};\n\n/**\n * kintone のスペースフィールドにボタン要素を追加または削除します。\n * - 既存の同 ID の要素は常に削除されます。\n * - 追加時は type=\"button\" として作成し、onClick が関数であれば click イベントを登録します。\n *\n * @param {string} spaceField スペースフィールドのフィールドコード\n * @param {string} id 追加するボタン要素の id\n * @param {string|null} textContent ボタンの表示テキスト。null/空なら要素を削除して非表示にする\n * @param {function|null|undefined} [onClick] クリック時に実行するコールバック（関数でない場合は無視される）\n * @returns {boolean|undefined} 要素の追加/削除に成功したら true/false を返します。入力が不正な場合は undefined を返すことがあります。\n */\nconst setSpaceFieldButton = (spaceField, id, textContent, onClick) => {\n  if (\n    typeof spaceField !== 'string' ||\n    !spaceField.trim() ||\n    typeof id !== 'string' ||\n    !id.trim() ||\n    (textContent !== null && typeof textContent !== 'string') ||\n    (onClick !== undefined && typeof onClick !== 'function' && onClick !== null)\n  ) {\n    return;\n  }\n  // 既存ボタン削除\n  const buttonElementById = document.getElementById(id);\n  if (buttonElementById) {\n    buttonElementById.remove();\n  }\n  if (textContent) {\n    // ボタン追加\n    const button = document.createElement('button');\n    // フォーム内で誤って submit を引き起こさないように type を明示する\n    button.type = 'button';\n    button.id = id;\n    button.textContent = textContent;\n    if (typeof onClick === 'function') {\n      button.addEventListener('click', onClick);\n    }\n    const spaceElement = kintone.app.record.getSpaceElement(spaceField);\n    if (!spaceElement) {\n      console.warn('setSpaceFieldButton: space element not found', spaceField);\n      return false;\n    }\n    spaceElement.appendChild(button);\n    setSpaceFieldDisplay(spaceField, true);\n    return true;\n  } else {\n    // 非表示\n    return setSpaceFieldDisplay(spaceField, false);\n  }\n};\n\n/**\n * kintone のスペースフィールド内に任意の HTML 文字列を挿入して表示／削除します。\n * - 挿入時は既存の同 ID 要素を削除してから追加します。\n * - innerHTML は内部でサニタイズされます。\n *\n * @param {string} spaceField スペースフィールドのフィールドコード\n * @param {string} id 追加する要素の id（既存要素があれば上書きの代わりに削除して再作成）\n * @param {string|null} innerHTML 表示する HTML。null/空文字 の場合は要素を削除して非表示にする\n * @returns {boolean} 成功したら true、引数不正や要素未発見などで失敗したら false\n */\nconst setSpaceFieldText = (spaceField, id, innerHTML) => {\n  if (\n    typeof spaceField !== 'string' ||\n    !spaceField.trim() ||\n    typeof id !== 'string' ||\n    !id.trim() ||\n    (innerHTML !== null && typeof innerHTML !== 'string')\n  ) {\n    console.warn('setSpaceFieldText: invalid arguments', {\n      spaceField,\n      id,\n      innerHTML,\n    });\n    return false;\n  }\n  // 既存要素削除\n  const spaceFieldElementById = document.getElementById(id);\n  if (spaceFieldElementById) {\n    spaceFieldElementById.remove();\n  }\n  if (innerHTML) {\n    // 表示\n    // createElement を関数化してリトライ時にも使えるようにする\n    const createSpaceFieldElement = () => {\n      const el = document.createElement('div');\n      el.id = id;\n      // innerHTML は HTML 形式での入力が想定されるため、可能な限りサニタイズしてから挿入する\n      el.innerHTML = _kc_sanitizeHtml(innerHTML);\n      return el;\n    };\n\n    // 初回アタック（同期的に試す）\n    let appended = false;\n    try {\n      const spaceElement = kintone.app.record.getSpaceElement(spaceField);\n      if (spaceElement) {\n        // 既に同 id の要素がある場合は削除してから追加\n        const existing = document.getElementById(id);\n        if (existing) existing.remove();\n        spaceElement.appendChild(createSpaceFieldElement());\n        appended = true;\n        // 表示を許可\n        setSpaceFieldDisplay(spaceField, true);\n      } else {\n        // do nothing here; we'll retry below\n      }\n    } catch (error) {\n      // ignore and let retry handle it\n      appended = false;\n    }\n\n    // 非同期リトライ: 一時的な早すぎる実行や別処理による上書きを数回の試行で修復する\n    // ※ 即時の戻り値は従来通り同期的な成功/失敗を返します（破壊的変更を避ける）\n    const startRetryLoop = () => {\n      // exponential backoff style intervals for faster initial response\n      const intervals = [50, 100, 200, 400, 800]; // ms\n      let idx = 0;\n      const tryOnce = () => {\n        // 要素が既に存在すれば成功とみなして終了\n        if (document.getElementById(id)) {\n          return;\n        }\n        // スペース要素が利用可能であれば追加を試みる\n        try {\n          const se = kintone.app.record.getSpaceElement(spaceField);\n          if (se) {\n            if (!document.getElementById(id)) {\n              se.appendChild(createSpaceFieldElement());\n              setSpaceFieldDisplay(spaceField, true);\n            }\n            return;\n          }\n        } catch (error) {\n          // ignore and will retry\n        }\n        // schedule next attempt if available\n        if (idx < intervals.length) {\n          const wait = intervals[idx++];\n          setTimeout(tryOnce, wait);\n        }\n      };\n\n      // kick off immediately (non-blocking)\n      setTimeout(tryOnce, 0);\n    };\n    // 実行\n    startRetryLoop();\n\n    return appended;\n  } else {\n    // 非表示\n    return setSpaceFieldDisplay(spaceField, false);\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/issiki_sigeo/Library/CloudStorage/OneDrive-公益社団法人神奈川県社会福祉士会/ドキュメント/kintone/アプリ開発/my-first-static-web-app/src/national_holiday_handling.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'err' is defined but never used. Allowed unused args must match /^_/u.","line":90,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":90,"endColumn":16,"suggestions":[{"messageId":"removeVar","data":{"varName":"err"},"fix":{"range":[2658,2661],"text":""},"desc":"Remove unused variable 'err'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 国民の祝日判定・取得用ユーティリティ関数群\n *\n * @fileoverview 国民の祝日API（https://api.national-holidays.jp）を利用し、指定日が祝日かどうかを判定します。\n * @author Shigeo Isshiki <issiki@kacsw.or.jp>\n * @version 1.0.0\n */\n// 関数命名ルール: 外部に見せる関数名はそのまま、内部で使用する関数名は(_nh_)で始める\n/* exported getNationalHolidayName */\n// リソースの読み込み制限を行っている場合は、fetch通信を下記のURLに対して許可する必要があります\n// https://api.national-holidays.jp\n'use strict';\n// --- 外部APIエンドポイント定数 ---\n/**\n * 祝日APIベースURL\n * @type {string}\n */\nconst _nh_HOLIDAY_API_BASE_URL = 'https://api.national-holidays.jp';\n/**\n * 国民の祝日処理用の統一エラークラス\n * @class\n * @extends {Error}\n * @param {string} message エラーメッセージ\n * @param {'logic'|'ajax'|'validation'|'unknown'} [type='unknown'] エラー種別\n * @property {string} name エラー名（NationalHolidayError）\n * @property {'logic'|'ajax'|'validation'|'unknown'} type エラー種別\n * @throws {Error} 継承元Errorの例外\n * @private\n */\nclass _nh_FinancialInstitutionError extends Error {\n  constructor(message, type = 'unknown') {\n    super(message);\n    this.name = 'NationalHolidayError';\n    this.type = type;\n  }\n}\n\n/**\n * 指定した日付が国民の祝日かどうかを判定し、祝日名またはnullをコールバックで返す（非同期）\n *\n * @function getNationalHolidayName\n * @param {string} date_str - ISO 8601拡張形式（YYYY-MM-DD）の日付文字列\n * @param {(holidayName: string|null) => void} callback - 祝日名（該当しなければnull）を返すコールバック関数\n * @returns {void}\n * @throws {_nh_FinancialInstitutionError} date_strやcallbackの型が不正な場合\n * @public\n * @example\n * getNationalHolidayName('2025-09-15', (name) => {\n *   if (name) {\n *     console.log('祝日:', name);\n *   } else {\n *     console.log('祝日ではありません');\n *   }\n * });\n *\n * @remarks\n * - 1948-07-20以前の日付は祝日判定対象外です。\n * - APIレスポンスの型チェックを行い、不正なデータは無視します。\n * - fetch通信エラーやAPI異常時は必ずnullを返します。\n */\nconst getNationalHolidayName = (date_str, callback) => {\n  if (typeof date_str !== 'string')\n    throw new _nh_FinancialInstitutionError('検索対象の日付は文字列である必要があります', 'logic');\n  if (typeof callback !== 'function')\n    throw new _nh_FinancialInstitutionError('コールバックは関数である必要があります', 'logic');\n  if (!date_str) return callback(null);\n  if (date_str < '1948-07-20') return callback(null);\n  fetch(_nh_HOLIDAY_API_BASE_URL + '/' + date_str)\n    .then((res) => {\n      if (!res.ok) {\n        throw new Error('祝日APIのレスポンスが不正です: ' + res.status);\n      }\n      return res.json();\n    })\n    .then((result) => {\n      // 祝日でない場合 { error: \"not_found\" }\n      if (result && typeof result === 'object') {\n        if (result.error === 'not_found') {\n          callback(null);\n          return;\n        }\n        if (typeof result.date === 'string' && typeof result.name === 'string') {\n          callback(result.name);\n          return;\n        }\n      }\n      // それ以外はnull\n      callback(null);\n    })\n    .catch((err) => {\n      // 通信エラーやAPI異常時も必ずnullで抜ける\n      callback(null);\n    });\n};\n\n// 公開（kintone から直接呼ばれるため）\nif (typeof window !== 'undefined') {\n  window.getNationalHolidayName = getNationalHolidayName;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/issiki_sigeo/Library/CloudStorage/OneDrive-公益社団法人神奈川県社会福祉士会/ドキュメント/kintone/アプリ開発/my-first-static-web-app/src/password_generation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/issiki_sigeo/Library/CloudStorage/OneDrive-公益社団法人神奈川県社会福祉士会/ドキュメント/kintone/アプリ開発/my-first-static-web-app/src/phone-utils.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'formatPhoneNumber' is assigned a value but never used.","line":1213,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":1213,"endColumn":24,"suggestions":[{"messageId":"removeVar","data":{"varName":"formatPhoneNumber"},"fix":{"range":[29861,31378],"text":""},"desc":"Remove unused variable 'formatPhoneNumber'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'getPhoneNumberType' is assigned a value but never used.","line":1285,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":1285,"endColumn":25,"suggestions":[{"messageId":"removeVar","data":{"varName":"getPhoneNumberType"},"fix":{"range":[31878,32204],"text":""},"desc":"Remove unused variable 'getPhoneNumberType'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'normalizePhoneNumber' is assigned a value but never used.","line":1306,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":1306,"endColumn":27,"suggestions":[{"messageId":"removeVar","data":{"varName":"normalizePhoneNumber"},"fix":{"range":[32375,32709],"text":""},"desc":"Remove unused variable 'normalizePhoneNumber'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** 日本の電話番号のフォーマット統一と日本の電話番号の種類を判定する処理をまとめたJavaScriptの関数群です。\n * @author Shigeo Isshiki <issiki@kacsw.or.jp>\n * @version 1.0.0\n */\n// 関数命名ルール: 外部に見せる関数名はそのまま、内部で使用する関数名は(_pu_)で始める\n'use strict';\n//　ライブラリ内の共通定数・変換テーブル定義部\n// ==================== 電話番号データ定義ここから ====================\n// ※この部分は総務省の最新データ（現状は2025年10月版）に合わせて随時差し替えてください\nconst _PU_PHONE_NUMBER_CONFIG = {\n  // 市外局番ごとの市内局番（もしくは局番）の桁数リスト\n  areaCodeList: {\n    5: {\n      '01267': 1,\n      '01372': 1,\n      '01374': 1,\n      '01377': 1,\n      '01392': 1,\n      '01397': 1,\n      '01398': 1,\n      '01456': 1,\n      '01457': 1,\n      '01466': 1,\n      '01547': 1,\n      '01558': 1,\n      '01564': 1,\n      '01586': 1,\n      '01587': 1,\n      '01632': 1,\n      '01634': 1,\n      '01635': 1,\n      '01648': 1,\n      '01654': 1,\n      '01655': 1,\n      '01656': 1,\n      '01658': 1,\n      '04992': 1,\n      '04994': 1,\n      '04996': 1,\n      '04998': 1,\n      '05769': 1,\n      '05979': 1,\n      '07468': 1,\n      '08512': 1,\n      '08514': 1,\n      '08477': 1,\n      '08387': 1,\n      '08388': 1,\n      '08396': 1,\n      '09802': 1,\n      '09912': 1,\n      '09913': 1,\n      '09969': 1,\n    },\n    4: {\n      '0123': 2,\n      '0124': 2,\n      '0125': 2,\n      '0126': 2,\n      '0133': 2,\n      '0134': 2,\n      '0135': 2,\n      '0136': 2,\n      '0137': 2,\n      '0138': 2,\n      '0139': 2,\n      '0142': 2,\n      '0143': 2,\n      '0144': 2,\n      '0145': 2,\n      '0146': 2,\n      '0152': 2,\n      '0153': 2,\n      '0154': 2,\n      '0155': 2,\n      '0156': 2,\n      '0157': 2,\n      '0158': 2,\n      '0162': 2,\n      '0163': 2,\n      '0164': 2,\n      '0165': 2,\n      '0166': 2,\n      '0167': 2,\n      '0172': 2,\n      '0173': 2,\n      '0174': 2,\n      '0175': 2,\n      '0176': 2,\n      '0178': 2,\n      '0179': 2,\n      '0182': 2,\n      '0183': 2,\n      '0184': 2,\n      '0185': 2,\n      '0186': 2,\n      '0187': 2,\n      '0191': 2,\n      '0192': 2,\n      '0193': 2,\n      '0194': 2,\n      '0195': 2,\n      '0197': 2,\n      '0198': 2,\n      '0220': 2,\n      '0223': 2,\n      '0224': 2,\n      '0225': 2,\n      '0226': 2,\n      '0228': 2,\n      '0229': 2,\n      '0233': 2,\n      '0234': 2,\n      '0235': 2,\n      '0237': 2,\n      '0238': 2,\n      '0240': 2,\n      '0241': 2,\n      '0242': 2,\n      '0243': 2,\n      '0244': 2,\n      '0246': 2,\n      '0247': 2,\n      '0248': 2,\n      '0250': 2,\n      '0254': 2,\n      '0255': 2,\n      '0256': 2,\n      '0257': 2,\n      '0258': 2,\n      '0259': 2,\n      '0260': 2,\n      '0261': 2,\n      '0263': 2,\n      '0264': 2,\n      '0265': 2,\n      '0266': 2,\n      '0267': 2,\n      '0268': 2,\n      '0269': 2,\n      '0270': 2,\n      '0274': 2,\n      '0276': 2,\n      '0277': 2,\n      '0278': 2,\n      '0279': 2,\n      '0280': 2,\n      '0282': 2,\n      '0283': 2,\n      '0284': 2,\n      '0285': 2,\n      '0287': 2,\n      '0288': 2,\n      '0289': 2,\n      '0291': 2,\n      '0293': 2,\n      '0294': 2,\n      '0295': 2,\n      '0296': 2,\n      '0297': 2,\n      '0299': 2,\n      '0422': 2,\n      '0428': 2,\n      '0436': 2,\n      '0438': 2,\n      '0439': 2,\n      '0460': 2,\n      '0463': 2,\n      '0465': 2,\n      '0466': 2,\n      '0467': 2,\n      '0470': 2,\n      '0475': 2,\n      '0476': 2,\n      '0478': 2,\n      '0479': 2,\n      '0480': 2,\n      '0493': 2,\n      '0494': 2,\n      '0495': 2,\n      '0531': 2,\n      '0532': 2,\n      '0533': 2,\n      '0536': 2,\n      '0537': 2,\n      '0538': 2,\n      '0539': 2,\n      '0544': 2,\n      '0545': 2,\n      '0547': 2,\n      '0548': 2,\n      '0550': 2,\n      '0551': 2,\n      '0553': 2,\n      '0554': 2,\n      '0555': 2,\n      '0556': 2,\n      '0557': 2,\n      '0558': 2,\n      '0561': 2,\n      '0562': 2,\n      '0563': 2,\n      '0564': 2,\n      '0565': 2,\n      '0566': 2,\n      '0567': 2,\n      '0568': 2,\n      '0569': 2,\n      '0572': 2,\n      '0573': 2,\n      '0574': 2,\n      '0575': 2,\n      '0576': 2,\n      '0577': 2,\n      '0578': 2,\n      '0581': 2,\n      '0584': 2,\n      '0585': 2,\n      '0586': 2,\n      '0587': 2,\n      '0594': 2,\n      '0595': 2,\n      '0596': 2,\n      '0597': 2,\n      '0598': 2,\n      '0599': 2,\n      '0721': 2,\n      '0725': 2,\n      '0735': 2,\n      '0736': 2,\n      '0737': 2,\n      '0738': 2,\n      '0739': 2,\n      '0740': 2,\n      '0742': 2,\n      '0743': 2,\n      '0744': 2,\n      '0745': 2,\n      '0746': 2,\n      '0747': 2,\n      '0748': 2,\n      '0749': 2,\n      '0761': 2,\n      '0763': 2,\n      '0765': 2,\n      '0766': 2,\n      '0767': 2,\n      '0768': 2,\n      '0770': 2,\n      '0771': 2,\n      '0772': 2,\n      '0773': 2,\n      '0774': 2,\n      '0776': 2,\n      '0778': 2,\n      '0779': 2,\n      '0790': 2,\n      '0791': 2,\n      '0794': 2,\n      '0795': 2,\n      '0796': 2,\n      '0797': 2,\n      '0798': 2,\n      '0799': 2,\n      '0820': 2,\n      '0823': 2,\n      '0824': 2,\n      '0826': 2,\n      '0827': 2,\n      '0829': 2,\n      '0833': 2,\n      '0834': 2,\n      '0835': 2,\n      '0836': 2,\n      '0837': 2,\n      '0838': 2,\n      '0845': 2,\n      '0846': 2,\n      '0847': 2,\n      '0848': 2,\n      '0852': 2,\n      '0853': 2,\n      '0854': 2,\n      '0855': 2,\n      '0856': 2,\n      '0857': 2,\n      '0858': 2,\n      '0859': 2,\n      '0863': 2,\n      '0865': 2,\n      '0866': 2,\n      '0867': 2,\n      '0868': 2,\n      '0869': 2,\n      '0875': 2,\n      '0877': 2,\n      '0879': 2,\n      '0880': 2,\n      '0883': 2,\n      '0884': 2,\n      '0885': 2,\n      '0887': 2,\n      '0889': 2,\n      '0892': 2,\n      '0893': 2,\n      '0894': 2,\n      '0895': 2,\n      '0896': 2,\n      '0897': 2,\n      '0898': 2,\n      '0920': 2,\n      '0930': 2,\n      '0940': 2,\n      '0942': 2,\n      '0943': 2,\n      '0944': 2,\n      '0946': 2,\n      '0947': 2,\n      '0948': 2,\n      '0949': 2,\n      '0950': 2,\n      '0952': 2,\n      '0954': 2,\n      '0955': 2,\n      '0956': 2,\n      '0957': 2,\n      '0959': 2,\n      '0964': 2,\n      '0965': 2,\n      '0966': 2,\n      '0967': 2,\n      '0968': 2,\n      '0969': 2,\n      '0972': 2,\n      '0973': 2,\n      '0974': 2,\n      '0977': 2,\n      '0978': 2,\n      '0979': 2,\n      '0980': 2,\n      '0982': 2,\n      '0983': 2,\n      '0984': 2,\n      '0985': 2,\n      '0986': 2,\n      '0987': 2,\n      '0993': 2,\n      '0994': 2,\n      '0995': 2,\n      '0996': 2,\n      '0997': 2,\n      '0120': 3,\n      '0800': 3,\n      '0170': 3,\n      '0180': 3,\n      '0570': 3,\n      '0990': 3,\n      '0200': 5,\n      '0204': 3,\n      '0600': 3,\n    },\n    3: {\n      '011': 3,\n      '015': 3,\n      '017': 3,\n      '018': 3,\n      '019': 3,\n      '022': 3,\n      '023': 3,\n      '024': 3,\n      '025': 3,\n      '026': 3,\n      '027': 3,\n      '028': 3,\n      '029': 3,\n      '042': 3,\n      '043': 3,\n      '044': 3,\n      '045': 3,\n      '046': 3,\n      '047': 3,\n      '048': 3,\n      '049': 3,\n      '052': 3,\n      '053': 3,\n      '054': 3,\n      '055': 3,\n      '058': 3,\n      '059': 3,\n      '072': 3,\n      '073': 3,\n      '075': 3,\n      '076': 3,\n      '077': 3,\n      '078': 3,\n      '079': 3,\n      '082': 3,\n      '083': 3,\n      '084': 3,\n      '086': 3,\n      '087': 3,\n      '088': 3,\n      '089': 3,\n      '092': 3,\n      '093': 3,\n      '095': 3,\n      '096': 3,\n      '097': 3,\n      '098': 3,\n      '099': 3,\n      '020': 3,\n      '060': 4,\n      '070': 4,\n      '080': 4,\n      '090': 4,\n      '050': 4,\n      '091': 3,\n    },\n    2: {\n      '03': 4,\n      '04': 4,\n      '06': 4,\n    },\n  },\n  // 電話番号市外局番ごとの市内局番（もしくは局番）の番号範囲リスト\n  // 市内局番（もしくは局番）の最初の2桁が範囲に含まれる場合、その市外局番を適用する\n  // 例：市外局番が0123の場合、市内局番の最初の2桁が20～50、52～60、62～70、72～80、82～99のいずれかに該当する場合に0123を適用\n  areaCodeRanges: {\n    '011': '200-899',\n    '0123': '20-50,52-60,62-70,72-80,82-99',\n    '0124': '20,22-39',\n    '0125': '20-99',\n    '0126': '20-60,62-69',\n    '01267': '2-9',\n    '0133': '20,22-39,60,62-79',\n    '0134': '20-99',\n    '0135': '20-49,60-79',\n    '0136': '20-79',\n    '01372': '2-9',\n    '01374': '2-9',\n    '0137': '50-60,62-69,80,82-89',\n    '01377': '2-9',\n    '0138': '20-99',\n    '01392': '2-9',\n    '0139': '30-40,42-50,52-60,62-69',\n    '01397': '2-9',\n    '01398': '2-9',\n    '0142': '20-99',\n    '0143': '20-99',\n    '0144': '20-99',\n    '0145': '20,22-40,42-59',\n    '01456': '2-9',\n    '01457': '2-9',\n    '0146': '20,22-30,32-40,42-59',\n    '01466': '2-9',\n    '0152': '20,22-70,72-89',\n    '0153': '20,22-50,52-70,72-80,82-99',\n    '015': '410-416,417-419,480,482-489,510-516,518-519,570,572-579',\n    '0154': '20-69,90-99',\n    '01547': '2-9',\n    '0155': '20-69,90-99',\n    '01558': '2-9',\n    '0156': '20,22-39,60,62-79',\n    '01564': '2-9',\n    '0157': '20-99',\n    '0158': '20,22-40,42-59,80,82-99',\n    '01586': '2-9',\n    '01587': '2-9',\n    '0162': '20-99',\n    '01632': '2-9',\n    '01634': '2-9',\n    '01635': '2-9',\n    '0163': '60,62-80,82-99',\n    '0164': '20,22-30,32-40,42-50,52-60,62-79',\n    '01648': '2-9',\n    '0165': '20,22-30,32-39',\n    '01654': '2-9',\n    '01655': '2-9',\n    '01656': '2-9',\n    '01658': '2-9',\n    '0166': '20-99',\n    '0167': '20-99',\n    '0172': '20-99',\n    '0173': '20-89',\n    '0174': '20-99',\n    '0175': '20-49,60-79',\n    '0176': '20-99',\n    '0177': '700-716,718-799',\n    '0178': '20-99',\n    '0179': '20-99',\n    '0182': '20-99',\n    '0183': '20-99',\n    '0184': '20-99',\n    '0185': '20-89',\n    '0186': '20-99',\n    '0187': '30-89',\n    '018': '800-899',\n    '0191': '20-99',\n    '0192': '20-99',\n    '0193': '20-99',\n    '0194': '20-79',\n    '0195': '20-89',\n    '0196': '600-616,618-699,900-929',\n    '0197': '20-89',\n    '0198': '20-49,60-79',\n    '0220': '20-99',\n    '022': '200-309,340-399,700-799',\n    '0223': '20-39',\n    '0224': '20-89',\n    '0225': '20-99',\n    '0226': '20-99',\n    '0228': '20-99',\n    '0229': '20-99',\n    '0233': '20-99',\n    '0234': '20-99',\n    '0235': '20-99',\n    '023': '600-616,618-699',\n    '0237': '20-89',\n    '0238': '20-99',\n    '0240': '20-49',\n    '0241': '20-76,78-99',\n    '0242': '20-99',\n    '0243': '20-99',\n    '0244': '20-99',\n    '0245': '500-516,518-599,900-916,918-999',\n    '0246': '20-99',\n    '0247': '20-89',\n    '0248': '20-99',\n    '0250': '20-99',\n    '025': '200-216,218-399,500-516,518-569,590,592-609,700-716,718-719,750-790,792-809',\n    '0254': '20-90,92-99',\n    '0255': '70-89',\n    '0256': '20-99',\n    '0257': '20-49',\n    '0258': '20-99',\n    '0259': '20-89',\n    '0260': '20-39',\n    '0261': '20-76,78-99',\n    '026': '200-299,400-409,460-499',\n    '0263': '20-99',\n    '0264': '20-59',\n    '0265': '20-99',\n    '0266': '20-99',\n    '0267': '20-99',\n    '0268': '20-99',\n    '0269': '20-89',\n    '0270': '20-99',\n    '027': '200-399,800-809,880-899',\n    '0274': '20-89',\n    '0276': '20-99',\n    '0277': '20-99',\n    '0278': '20-79',\n    '0279': '20-99',\n    '0280': '20-99',\n    '0282': '20-99',\n    '028': '300-309,330-349,600-699,900-909,920-959',\n    '0283': '20-29,50-99',\n    '0284': '20-99',\n    '0285': '20-99',\n    '0287': '20-99',\n    '0288': '20-99',\n    '0289': '60-99',\n    '0291': '30-49',\n    '029': '200-309,350-399,800-899',\n    '0293': '20-49',\n    '0294': '20-99',\n    '0295': '50-70,72-79',\n    '0296': '20-59,70-89',\n    '0297': '20-99',\n    '0299': '20-99',\n    '03': '3100-3999,4200-4599,5000-5999,6100-6999',\n    '04': '2000-2009,2900-2909,2920-2969,2990-2999,7000-7009,7090-7116,7118-7176,7178-7199',\n    '042':\n      '200-209,300-316,318-416,418-516,518-599,610-616,618-670,672-680,682-716,718-730,732-780,782-816,818-819,840-869,910-916,918-919,970-989',\n    '0422': '20-99',\n    '0428': '20-39,70-99',\n    '043': '200-499',\n    '0436': '20-99',\n    '0438': '20-99',\n    '0439': '20-99',\n    '044': '200-999',\n    '045': '200-999',\n    '0460': '80-89',\n    '046': '200-216,218-299,400-419,800-816,818-899',\n    '0463': '20-99',\n    '0465': '20-99',\n    '0466': '20-99',\n    '0467': '20-99',\n    '0470': '20-89',\n    '047': '300-499,700-729,750-779',\n    '0475': '20-89',\n    '0476': '20-99',\n    '0478': '50-89',\n    '0479': '20-89',\n    '0480': '20-99',\n    '048': '200-299,400-999',\n    '049': '200-299',\n    '0493': '20-99',\n    '0494': '20-99',\n    '0495': '20-99',\n    '04992': '2-9',\n    '04994': '2-9',\n    '04996': '2-9',\n    '04998': '2-9',\n    '052': '200-999',\n    '0531': '20-49',\n    '0532': '20-99',\n    '0533': '20-99',\n    '053': '400-599,920-959,964-973,975-976,978-989',\n    '0536': '20-39,60-89',\n    '0537': '20-99',\n    '0538': '20-99',\n    '0539': '60-63,74,77,90-99',\n    '054': '200-299,320-399,600-699,900-909',\n    '0556': '20-60,62-69',\n    '0544': '20-99',\n    '0545': '20-99',\n    '0547': '20-99',\n    '0548': '20-99',\n    '0550': '20-99',\n    '0551': '20-76,78-99',\n    '055': '200-216,218-299,900-916,918-999',\n    '0553': '20-99',\n    '0554': '20-99',\n    '0555': '20-99',\n    '0557': '20-99',\n    '0558': '20-99',\n    '0561': '20-76,78-99',\n    '0562': '20-99',\n    '0563': '20-99',\n    '0564': '20-99',\n    '0565': '20-99',\n    '0566': '20-99',\n    '0567': '20-99',\n    '0568': '20-99',\n    '0569': '20-99',\n    '0572': '20-99',\n    '0573': '20-89',\n    '0574': '20-89',\n    '0575': '20-89',\n    '0576': '20-89',\n    '05769': '2-9',\n    '0577': '20-99',\n    '0578': '70-89',\n    '0581': '20-76,78-99',\n    '058': '200-399',\n    '0584': '20-99',\n    '0585': '20-99',\n    '0586': '20-99',\n    '0587': '20-99',\n    '059': '200-299,310-399,990-999',\n    '0594': '20-99',\n    '0595': '20-99',\n    '0596': '20-79',\n    '0597': '20-39,42-49,70-90,97-98',\n    '05979': '2-6,9',\n    '0598': '20-89',\n    '0599': '20-89',\n    '06': '4100-4999,6100-6999,7100-7999',\n    '0721': '20-76,78-99',\n    '072': '200-499,600-999',\n    '0725': '20-99',\n    '073': '400-499',\n    '0735': '20-79',\n    '0736': '20-89',\n    '0737': '20-99',\n    '0738': '20-99',\n    '0739': '20-99',\n    '0740': '20-39',\n    '0742': '20-99',\n    '0743': '20-99',\n    '0744': '20-99',\n    '0745': '20-99',\n    '0746': '30-69',\n    '07468': '2-9',\n    '0747': '20-69',\n    '0748': '20-89',\n    '0749': '20-89',\n    '075': '200-999',\n    '0761': '20-84',\n    '076': '200-216,218-299,400-416,418-499',\n    '0763': '20-99',\n    '0765': '20-99',\n    '0766': '20-99',\n    '0767': '20-89',\n    '0768': '20-89',\n    '0770': '20-79',\n    '0771': '20-89',\n    '0772': '20-89',\n    '0773': '20-89',\n    '0774': '20-99',\n    '077': '500-516,518-599',\n    '0776': '20-99',\n    '0778': '20-99',\n    '0779': '60-71,77-89',\n    '078': '200-999',\n    '0790': '20-89',\n    '0791': '20-29,40-79',\n    '079': '200-339,400-409,420-459,490-509,550-569,590-609,660-679',\n    '0794': '60-89',\n    '0795': '20-49,70-89',\n    '0796': '20-59,80-99',\n    '0797': '20-99',\n    '0798': '20-99',\n    '0799': '20-89',\n    '0820': '20-89',\n    '082': '200-299,400-409,420-439,490-599,800-909,921-929,941-943,960-969,990-999',\n    '0823': '20-99',\n    '0824': '40-89',\n    '0826': '20-89',\n    '0827': '20-50,52-99',\n    '0829': '20,30-40,44-59,70-89',\n    '083': '220-299,600-609,766-768,770-789,900-950,952-960,963,966,970-999',\n    '0833': '20-99',\n    '0834': '20-99',\n    '0835': '20-99',\n    '0836': '20-99',\n    '0837': '20-65,69',\n    '0838': '20-59',\n    '08387': '2-9',\n    '08388': '2-9',\n    '08396': '2,4-5,7-9',\n    '0845': '20-39',\n    '0846': '20-49,60-79',\n    '0847': '20-69,80-99',\n    '08477': '2-9',\n    '0848': '20-99',\n    '084': '900-999',\n    '08512': '2-9',\n    '08514': '2-9',\n    '0852': '20-99',\n    '0853': '20-99',\n    '0854': '20-99',\n    '0855': '20-99',\n    '0856': '20-59,70-89',\n    '0857': '20-99',\n    '0858': '20-89',\n    '0859': '20-89',\n    '086':\n      '200-299,362-365,367-369,420-489,520-529,552-553,600-609,691,697-698,722-724,726,728,737-738,800-809,890-909,940-959,994-999',\n    '0863': '20-59,66,70-89',\n    '0865': '40-51,54-79',\n    '0866': '20-90,92-96,99',\n    '0867': '20-21,25,27,29-36,39-99',\n    '0868': '20-89',\n    '0869': '20-29,34,60-89,92-93',\n    '0875': '20-99',\n    '0877': '20-99',\n    '087': '800-899',\n    '0879': '20-89',\n    '0880': '20-99',\n    '0883': '20-89',\n    '0884': '20-89',\n    '0885': '30,32-40,42-49',\n    '088': '600-616,618-699,800-816,818-899',\n    '0887': '20,22-99',\n    '0889': '20-69',\n    '0892': '20-99',\n    '0893': '20-99',\n    '0894': '20-99',\n    '0895': '20-89',\n    '0896': '20-99',\n    '0897': '20-89',\n    '0898': '20-99',\n    '089': '900-999',\n    '0920': '40-59,80-89',\n    '092': '200-999',\n    '0930': '20-59',\n    '093': '200-999',\n    '0940': '20-99',\n    '0942': '20-99',\n    '0943': '20-59,70-89',\n    '0944': '20-99',\n    '0946': '20-99',\n    '0947': '20-99',\n    '0948': '20-99',\n    '0949': '20-59,62-69',\n    '0950': '20-99',\n    '0952': '20-99',\n    '0954': '20-49,60-79',\n    '0955': '20-89',\n    '0956': '20-99',\n    '0957': '20-89',\n    '095': '800-899',\n    '0959': '20-99',\n    '096': '200-399',\n    '0964': '20-99',\n    '0965': '20-99',\n    '0966': '20,22-89',\n    '0967': '20,22-99',\n    '0968': '20-89',\n    '0969': '20-89',\n    '0972': '20-89',\n    '0973': '20-59,70-89',\n    '0974': '20,22-49,60,62-79',\n    '097': '500-599',\n    '0977': '20-99',\n    '0978': '20,22-60,62-99',\n    '0979': '20-99',\n    '09802': '2-9',\n    '0980': '30-70,72-80,82-99',\n    '0982': '20-99',\n    '0983': '20-99',\n    '0984': '20-99',\n    '0985': '20-99',\n    '0986': '20-99',\n    '0987': '20-99',\n    '098': '800-999',\n    '09912': '2-9',\n    '09913': '2-9',\n    '099': '200-216,218-299,331,343,345,347,400-409,470-489,800-839',\n    '0993': '20-30,32-42,44,46,48-89',\n    '0994': '20-69,90-99',\n    '0995': '20-79',\n    '0996': '20-89',\n    '09969': '2-9',\n    '0997': '20,22-99',\n    '0120': '0-999',\n    '0800': '0-999',\n    '0570': '0-999',\n    '0990': '0-999',\n    '020': '100-399,500-999',\n    '0200': '10000-10999',\n    '060': '1000-9999',\n    '070': '1000-9999',\n    '080': '1000-9999',\n    '090': '1000-9999',\n    '050': '1000-9999',\n  },\n  // 11桁の表記の電気通信番号の市外局番リスト\n  // これらの市外局番の場合、電話番号は11桁である必要がある\n  // 例：0800、020、060、070、080、090、0204、050、0600　'0800', '020', '060', '070', '080', '090', '0204', '050', '0600'\n  digit11PhoneNumberRange: {\n    service: ['0800'],\n    m2m: ['020'],\n    mobile: ['060', '070', '080', '090'],\n    wireless: ['0204'],\n    ipphone: ['050'],\n    fmc: ['0600'],\n  },\n  // 固定電話番号でない市外局番リスト\n  // これらの市外局番の場合、固定電話番号としてのチェックを行わない\n  // 例：0120、0170、0180、0570、0990\n  notLandlinePhoneNumberRange: ['0120', '0170', '0180', '0570', '0990'],\n  // 属性判定ルール\n  // - callCapableTypes: 通話可能とみなす type の一覧\n  // - faxExcludedTypes: FAX 判定から除外する type の一覧\n  // - mobileType: 携帯電話を示す type 名（通常 '携帯電話'）\n  callCapableTypes: ['固定電話', '着信課金', '統一番号', '携帯電話', 'IP電話'],\n  faxExcludedTypes: ['IP電話', '携帯電話'],\n  mobileType: '携帯電話',\n};\n// ==================== 電話番号データ定義ここまで ====================\n\n// 電話番号で使用される可能性のある記号を検出するための正規表現\nconst _PU_SYMBOLS_REGEX = /[()（）\\[\\]［］{}｛｝\\-－‐‑–—−ー―.．。･・\\/／\\\\＼ 　\\t\\n\\r]/g;\n\n// 全角数字を検出するための正規表現\nconst _PU_ZENKAKU_NUM_REGEX = /[０-９]/g;\n\n//　ライブラリ内の共通関数定義部\n/**\n * 電話番号の市外局番情報を取得する\n * @param {number} codeLength 市外局番の桁数\n * @param {string} code 市外局番\n * @returns {number|undefined} 市外局番情報（市外局番の桁数）、該当しない場合はundefined\n */\nconst _pu_getAreaCodeInfo = (codeLength, code) => {\n  return _PU_PHONE_NUMBER_CONFIG.areaCodeList[codeLength]?.[code];\n};\n\n/**\n * 市外局番の桁数リストのキャッシュ（降順ソート済み）\n * @type {number[]|null}\n */\nlet _pu_areaCodeListCache = null;\n\n/**\n * 市外局番の桁数リストを降順で取得する（キャッシュ機能付き）\n * 初回呼び出し時にソート済みリストを作成し、以降はキャッシュを返す\n * @returns {number[]} 市外局番の桁数リスト（降順）例: [5, 4, 3, 2]\n */\nconst _pu_getAreaCodeList = () => {\n  if (_pu_areaCodeListCache) return _pu_areaCodeListCache;\n  _pu_areaCodeListCache = Object.keys(_PU_PHONE_NUMBER_CONFIG.areaCodeList)\n    .map(Number)\n    .sort((a, b) => b - a);\n  return _pu_areaCodeListCache;\n};\n\n/**\n * 範囲文字列を数値範囲の配列に展開する\n * 例: \"20-30,35,40-50\" → [[20,30], [35,35], [40,50]]\n * @param {string} rangeStr 範囲文字列（例: \"20-30,35,40-50\", \"2-9\", \"200-899\"）\n * @returns {number[][]|null} 数値範囲の配列（各要素は[開始値, 終了値]）、無効な場合はnull\n */\nconst _pu_expandRangeString = (rangeStr) => {\n  if (!rangeStr) return null;\n  return rangeStr.split(',').map((part) => {\n    if (part.includes('-')) {\n      const [start, end] = part.split('-').map(Number);\n      return [start, end];\n    } else {\n      const n = Number(part);\n      return [n, n];\n    }\n  });\n};\n\n/**\n * 市外局番に対応する市内局番（もしくは局番）の番号範囲リストを取得する\n * @param {string} code 市外局番\n * @returns {number[][]|undefined} 市内局番（もしくは局番）の番号範囲リスト、該当しない場合はundefined\n */\nconst _pu_getLocalAreaCodeRange = (code) => {\n  const val = _PU_PHONE_NUMBER_CONFIG.areaCodeRanges[code];\n  if (!val) return undefined;\n  return _pu_expandRangeString(val);\n};\n\n/**\n * 11桁の表記の電話番号の市外局番リストを取得する\n * @param {string} type 種別（service:フリーダイヤル、m2m: M2M、mobile:携帯電話、wireless: 無線呼出、ipphone: IP電話、fmc: FMC）\n * @returns {string[]} 市外局番リスト、該当しない場合は空配列\n */\nconst _pu_getDigit11PrefixList = (type) => {\n  return _PU_PHONE_NUMBER_CONFIG.digit11PhoneNumberRange &&\n    _PU_PHONE_NUMBER_CONFIG.digit11PhoneNumberRange[type]\n    ? _PU_PHONE_NUMBER_CONFIG.digit11PhoneNumberRange[type]\n    : [];\n};\n\n/**\n * 11桁の表記の電話番号の市外局番範囲かどうかを判定する\n * @param {string} code 市外局番\n * @returns {boolean} 11桁の市外局番範囲に含まれる場合はtrue、そうでない場合はfalse\n */\nconst _pu_isDigit11PhoneNumberRange = (code) => {\n  const allPrefixes = Object.values(_PU_PHONE_NUMBER_CONFIG.digit11PhoneNumberRange).flat();\n  return allPrefixes.includes(code);\n};\n\n/**\n * 固定電話番号でない市外局番範囲かどうかを判定する\n * @param {string} code 市外局番\n * @returns {boolean} 固定電話番号でない市外局番範囲に含まれる場合はtrue、そうでない場合はfalse\n */\nconst _pu_isNotLandlinePhoneNumberRange = (code) => {\n  return _PU_PHONE_NUMBER_CONFIG.notLandlinePhoneNumberRange.includes(code);\n};\n\n/**\n * 電話番号として処理できる数字のみの文字列に変換する関数（正規化）\n * @param {string|number|null|undefined} str 電話番号の文字列\n * @returns {string} 電話番号として処理できる数字のみの文字列\n * @throws {Error} 不正な場合は例外\n */\nconst _pu_getPhoneNumberOnly = (str) => {\n  if (!str) {\n    throw new Error('電話番号が空です');\n  }\n  const result = String(str)\n    .replace(_PU_SYMBOLS_REGEX, '') // 記号除去\n    .replace(_PU_ZENKAKU_NUM_REGEX, (s) => String.fromCharCode(s.charCodeAt(0) - 0xfee0)); // 全角数字→半角\n\n  if (!result || !/^\\d+$/.test(result)) {\n    throw new Error(\n      `電話番号として無効です（数字以外の文字が含まれているか、数字が含まれていません）: ${str}`\n    );\n  }\n\n  return result;\n};\n\n/**\n * 電話番号の種別を判定する関数\n * @param {string|number|null|undefined} number 電話番号\n * @returns {string} '固定電話' | '携帯電話' | '着信課金' | '付加サービス' | '無線呼出' | '不明'\n * @throws {Error} 不正な場合は例外\n */\nconst _pu_getPhoneType = (number) => {\n  const num = _pu_getPhoneNumberOnly(number); // この時点でエラーが投げられる可能性あり\n  // 091で始まる6～13桁の特定接続番号\n  if (num.startsWith('091') && num.length >= 6 && num.length <= 13) {\n    return '特定接続';\n  }\n  // 14桁番号のtype判定\n  if (num.length === 14) {\n    const prefix4 = num.substring(0, 4);\n    if (prefix4 === '0200') return 'M2M'; // 0200はM2M専用\n  }\n  // 11桁番号のtype判定（digit11PhoneNumberRangeの各typeに対応）\n  if (num.length === 11) {\n    // 4桁prefix優先\n    const prefix4 = num.substring(0, 4);\n    const prefix3 = num.substring(0, 3);\n    if (_pu_getDigit11PrefixList('service').includes(prefix4)) return '着信課金';\n    if (_pu_getDigit11PrefixList('wireless').includes(prefix4)) return '無線呼出';\n    if (_pu_getDigit11PrefixList('fmc').includes(prefix4)) return 'FMC';\n    if (_pu_getDigit11PrefixList('m2m').includes(prefix3)) return 'M2M';\n    if (_pu_getDigit11PrefixList('m2m').includes(prefix4)) return 'M2M';\n    if (_pu_getDigit11PrefixList('mobile').includes(prefix3)) return '携帯電話';\n    if (_pu_getDigit11PrefixList('ipphone').includes(prefix3)) return 'IP電話';\n  }\n  // 10桁特殊番号（0120は着信課金、その他は付加サービス）\n  if (num.length === 10 && _pu_isNotLandlinePhoneNumberRange(num.substring(0, 4))) {\n    const prefix4 = num.substring(0, 4);\n    // 0120 は着信課金、0570 は統一番号として扱う（ナビダイヤル等）\n    if (prefix4 === '0120') return '着信課金';\n    if (prefix4 === '0570') return '統一番号';\n    return '付加サービス';\n  }\n  if (num.length === 10) {\n    return '固定電話';\n  }\n  return '不明';\n};\n\n/**\n * 電話番号の種別に応じたハイフンパターンを返す関数\n * @param {string|number|null|undefined} number 電話番号\n * @param {string} type - 電話番号種別\n * @returns {Array<number>} ハイフン位置の配列（例: [4,3,4]）\n */\nconst _pu_getHyphenPattern = (number, type) => {\n  const num = _pu_getPhoneNumberOnly(number);\n  if (!num) return [];\n  // 14桁の0200番号（M2M専用）は[4,5,5]で分割\n  if (num.length === 14 && num.startsWith('0200')) {\n    return [4, 5, 5];\n  }\n  // 11桁系番号（着信課金の0800を含む）\n  if (num.length === 11) {\n    if (\n      type === '携帯電話' ||\n      type === 'M2M' ||\n      type === '無線呼出' ||\n      type === 'FMC' ||\n      type === 'IP電話' ||\n      type === '着信課金'\n    ) {\n      // 4桁prefix（例: 0800, 0204, 0600）は[4,3,4]、3桁prefixは[3,4,4]\n      if (_pu_isDigit11PhoneNumberRange(num.substring(0, 4))) {\n        return [4, 3, 4];\n      }\n      return [3, 4, 4];\n    }\n  }\n  // 10桁系番号（着信課金の0120、付加サービス等）\n  if (\n    num.length === 10 &&\n    (type === '着信課金' || type === '付加サービス' || type === '統一番号')\n  ) {\n    // 例: 0120-123-456, 0570-123-456\n    return [4, 3, 3];\n  }\n  if (type === '固定電話') {\n    // 市外局番・市内局番・加入者番号の長さを判定\n    const areaCodeList = _pu_getAreaCodeList();\n    for (let c = 0, l = areaCodeList.length; c < l; c++) {\n      let areaCodeLen = areaCodeList[c];\n      let areaCode = num.substring(0, areaCodeLen);\n      let localLen = _pu_getAreaCodeInfo(areaCodeLen, areaCode);\n      if (localLen) {\n        const subscriberLen = num.length - areaCodeLen - localLen;\n        return [areaCodeLen, localLen, subscriberLen];\n      }\n    }\n    // 該当しない場合\n    return [3, 3, 4];\n  }\n  return [];\n};\n\n/**\n * 電話番号を正規化し、ハイフン付きでフォーマットする関数\n * @param {string|number|null|undefined} str 電話番号\n * @returns {string} フォーマット済み電話番号\n * @throws {Error} 不正な場合は例外\n */\nconst _pu_formatPhoneNumber = (str) => {\n  const num = _pu_getPhoneNumberOnly(str); // この時点でエラーが投げられる可能性あり\n\n  // 091特殊番号は必ず091-以下全て\n  if (num.startsWith('091') && num.length >= 6 && num.length <= 13) {\n    return `${num.substring(0, 3)}-${num.substring(3)}`;\n  }\n  const type = _pu_getPhoneType(num);\n  const pattern = _pu_getHyphenPattern(num, type);\n  if (!pattern.length) return num;\n  let idx = 0;\n  const parts = pattern.map((len) => {\n    const part = num.substring(idx, idx + len);\n    idx += len;\n    return part;\n  });\n  return parts.filter(Boolean).join('-');\n};\n\n/**\n * 日本国内用電話番号バリデーション関数\n * @param {string|number|null|undefined} str 電話番号の文字列\n * @returns {boolean} 有効な電話番号であればtrue、そうでなければfalse\n */\nconst _pu_isValidJapanesePhoneNumber = (str) => {\n  if (!str) return false;\n  const s = String(str).trim();\n  // 国番号(+81)や+で始まるものはNG\n  if (s.startsWith('+') || s.startsWith('81')) return false;\n  // 記号・全角数字除去\n  const num = _pu_getPhoneNumberOnly(s);\n  if (!num) return false;\n  // 先頭0でなければNG\n  if (!num.startsWith('0')) return false;\n  // areaCodeRangesに範囲指定があるprefixは、桁数に関係なく範囲チェックを行う\n  // 例：0200（14桁）、0800/0120/050/020/090/080（11桁）、0570/0990（10桁）など\n  const areaCodeList = _pu_getAreaCodeList();\n  for (let c = 0, l = areaCodeList.length; c < l; c++) {\n    let areaCodeLen = areaCodeList[c];\n    let areaCode = num.substring(0, areaCodeLen);\n    let localLen = _pu_getAreaCodeInfo(areaCodeLen, areaCode);\n    if (localLen) {\n      const ranges = _pu_getLocalAreaCodeRange(areaCode);\n      if (ranges) {\n        // localLenが桁数を超える場合は不正\n        if (num.length < areaCodeLen + localLen) return false;\n        let localCode = num.substring(areaCodeLen, areaCodeLen + localLen);\n        let localCodeNum = Number(localCode);\n        let inRange = false;\n        for (const [start, end] of ranges) {\n          if (localCodeNum >= start && localCodeNum <= end) {\n            inRange = true;\n            break;\n          }\n        }\n        if (!inRange) return false;\n      }\n      // 固定電話（10桁）の場合はここでtrue\n      if (num.length === 10) return true;\n      // 11桁や14桁などの場合は、areaCodeRangesの範囲チェックが通ればtrue（例：0200, 0800, 0120, 050, 020, 090, 080, 0570, 0990など）\n      if (num.length === areaCodeLen + localLen + (num.length - (areaCodeLen + localLen))) {\n        // 追加の桁数チェックはprefixごとに必要\n        // 例：0200は14桁、0800/0120/050/020/090/080は11桁、0570/0990は10桁\n        // areaCodeごとに桁数を厳密に判定\n        if (areaCode === '0200' && num.length === 14) return true;\n        if (\n          (areaCode === '0800' ||\n            areaCode === '0120' ||\n            areaCode === '050' ||\n            areaCode === '020' ||\n            areaCode === '090' ||\n            areaCode === '080' ||\n            areaCode === '070' ||\n            areaCode === '060') &&\n          num.length === 11\n        )\n          return true;\n        if ((areaCode === '0570' || areaCode === '0990') && num.length === 10) return true;\n      }\n    }\n  }\n  // 10桁番号でareaCodeRangesに該当しない場合はfalse（上記forでtrueにならなければfalse）\n  if (num.length === 10) return false;\n  // 091で始まる6～13桁の特殊番号を許可\n  if (num.startsWith('091') && num.length >= 6 && num.length <= 13) return true;\n  // 11桁はareaCodeRangesで範囲チェックが通った場合のみtrue（上記forでtrueにならなければfalse）\n  if (num.length === 11) return false;\n  return false;\n};\n\n//　ライブラリ本体部\n/**\n * 電話番号の有効性を検証する関数\n * @param {string|number|null|undefined} phoneNumber 電話番号\n * @returns {boolean} 有効な日本の電話番号かどうか（true:有効, false:無効）\n * @throws {Error} 入力値が空や型不正の場合\n */\nconst isValidPhoneNumber = (phoneNumber) => {\n  if (!phoneNumber) {\n    throw new Error('電話番号が指定されていません。文字列または数値を入力してください。');\n  }\n\n  try {\n    return _pu_isValidJapanesePhoneNumber(phoneNumber);\n  } catch (error) {\n    throw new Error(`電話番号の検証中にエラーが発生しました: ${error.message}`);\n  }\n};\n\n/**\n * 電話番号を正規化してフォーマットし、電話番号の種類と各種フラグを返すメイン関数\n *\n * @param {string|number|null|undefined} phoneNumber 電話番号（任意の記号や全角数字を含む文字列可）\n * @returns {Object} 結果オブジェクト\n *   - formattedNumber {string} : ハイフン付きでフォーマットされた電話番号（例: \"03-1234-5678\"）\n *   - type {string} : 判定された電話番号の種類。主な戻り値例:\n *       '固定電話', '携帯電話', '着信課金', '統一番号', 'IP電話', 'M2M', '無線呼出', 'FMC', '特定接続', '付加サービス', '不明'\n *   - callCapable {boolean} : 通話可能とみなす回線かどうか。次の種別を通話可能とする:\n *       ['固定電話','着信課金','統一番号','携帯電話','IP電話']\n *       上記に含まれる type のとき true、それ以外は false になります。\n *   - homeLine {boolean} : 自宅で使える回線（いわゆる固定回線）かどうか。\n *       定義: 通話可能（callCapable が true）かつ '携帯電話' でないものを true とする。\n *   - faxCapable {boolean} : FAX 送受信に適した回線かどうか。\n *       定義: 通話可能かつ 'IP電話' と '携帯電話' を除外したものを true とする。\n *   - mobile {boolean} : 携帯電話番号 ('携帯電話') かどうか。\n *\n * @throws {Error} 入力が空、あるいは日本の電話番号形式に合致しない場合にスローされます。\n *\n * 備考:\n *  - '0570' は本ライブラリでは '統一番号' として扱い、10桁は \"0570-xxx-xxx\" とフォーマットされます。\n *  - '091' で始まる6〜13桁は '特定接続' として許可されますが、今回の通話可能集合には含めていません。\n */\nconst formatPhoneNumber = (phoneNumber) => {\n  // 基本的な正規化とバリデーション\n  if (!phoneNumber) {\n    throw new Error('電話番号が指定されていません。文字列または数値を入力してください。');\n  }\n\n  let num;\n  try {\n    if (!isValidPhoneNumber(phoneNumber)) {\n      throw new Error('無効な電話番号です。電話番号の形式に合致しません。');\n    }\n    num = _pu_getPhoneNumberOnly(phoneNumber);\n  } catch (error) {\n    throw error;\n  }\n\n  const type = _pu_getPhoneType(num);\n  const formatted = _pu_formatPhoneNumber(num);\n\n  // 属性判定ルール（更新）\n  // - homeLine: 通話可能な種別で、かつ携帯電話ではないものを true とする\n  // - mobile: '携帯電話' のみ true\n  // - faxCapable: 通話可能な種別のうち IP 電話は除外する（携帯も除外）\n  // 通話可能／FAX等の属性判定は設定から読み込む（将来の変更を容易にする）\n  const cfgCallCapable = Array.isArray(_PU_PHONE_NUMBER_CONFIG.callCapableTypes)\n    ? _PU_PHONE_NUMBER_CONFIG.callCapableTypes\n    : ['固定電話', '着信課金', '統一番号', '携帯電話', 'IP電話'];\n  const cfgFaxExcluded = Array.isArray(_PU_PHONE_NUMBER_CONFIG.faxExcludedTypes)\n    ? _PU_PHONE_NUMBER_CONFIG.faxExcludedTypes\n    : ['IP電話', '携帯電話'];\n  const cfgMobileType = _PU_PHONE_NUMBER_CONFIG.mobileType || '携帯電話';\n\n  const callCapableTypes = new Set(cfgCallCapable);\n  const mobile = type === cfgMobileType;\n  const isCallCapable = callCapableTypes.has(type);\n  const homeLine = isCallCapable && !mobile; // 携帯を除外\n  // FAX は通話可能で、かつ設定で除外されたタイプを除外\n  const faxCapable = isCallCapable && !cfgFaxExcluded.includes(type) && !mobile;\n\n  return {\n    formattedNumber: formatted,\n    type: type,\n    callCapable: isCallCapable,\n    homeLine: homeLine,\n    faxCapable: faxCapable,\n    mobile: mobile,\n  };\n};\n\n/**\n * 電話番号の種別のみを返す関数\n *\n * @param {string|number|null|undefined} phoneNumber 電話番号（任意の記号や全角数字を含む文字列可）\n * @returns {string} 判定された電話番号の種類。可能な戻り値の例:\n *   - '固定電話'\n *   - '携帯電話'\n *   - '着信課金'\n *   - '統一番号'  // 0570（ナビダイヤル等）の扱い\n *   - 'IP電話'\n *   - 'M2M'\n *   - '無線呼出'\n *   - 'FMC'\n *   - '特定接続' // 091で始まる6〜13桁の番号\n *   - '付加サービス'\n *   - '不明'\n *\n * @throws {Error} 入力が空、または日本の電話番号形式に合致しない場合にスローされます。\n *\n * 備考:\n *  - 本関数の種別判定は `formatPhoneNumber` と同じ判定ロジックを使います。\n *  - 0570 プレフィックスは '統一番号' として扱われます。\n */\nconst getPhoneNumberType = (phoneNumber) => {\n  if (!phoneNumber) {\n    throw new Error('電話番号が指定されていません。文字列または数値を入力してください。');\n  }\n\n  try {\n    if (!isValidPhoneNumber(phoneNumber)) {\n      throw new Error('無効な電話番号です。電話番号の形式に合致しません。');\n    }\n    return _pu_getPhoneType(phoneNumber);\n  } catch (error) {\n    throw error;\n  }\n};\n\n/**\n * 電話番号を正規化して数字のみにする関数\n * @param {string|number|null|undefined} phoneNumber 電話番号\n * @returns {string} 数字のみの電話番号\n * @throws {Error} 無効な電話番号の場合（日本の電話番号形式に合致しない場合）\n */\nconst normalizePhoneNumber = (phoneNumber) => {\n  if (!phoneNumber) {\n    throw new Error('電話番号が指定されていません。文字列または数値を入力してください。');\n  }\n\n  try {\n    if (!isValidPhoneNumber(phoneNumber)) {\n      throw new Error('無効な電話番号です。電話番号の形式に合致しません。');\n    }\n    return _pu_getPhoneNumberOnly(phoneNumber);\n  } catch (error) {\n    throw error;\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/issiki_sigeo/Library/CloudStorage/OneDrive-公益社団法人神奈川県社会福祉士会/ドキュメント/kintone/アプリ開発/my-first-static-web-app/src/phone_number_translation.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'_pn_fallbackFormatPhoneNumber' is assigned a value but never used.","line":1176,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":1176,"endColumn":36,"suggestions":[{"messageId":"removeVar","data":{"varName":"_pn_fallbackFormatPhoneNumber"},"fix":{"range":[29397,30478],"text":""},"desc":"Remove unused variable '_pn_fallbackFormatPhoneNumber'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'phone_number_formatting_with_type' is assigned a value but never used.","line":1267,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":1267,"endColumn":40,"suggestions":[{"messageId":"removeVar","data":{"varName":"phone_number_formatting_with_type"},"fix":{"range":[32564,32987],"text":""},"desc":"Remove unused variable 'phone_number_formatting_with_type'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 電話番号統一フォーマット処理用ユーティリティ関数群\n * このプログラムは、電話番号のフォーマットを統一するためのものです。\n * 電話番号の市外局番、携帯電話番号等の電気通信番号の指定通信番号の桁数、市内局番の桁数、もしくは局番の桁数を考慮してハイフン位置を修正します。\n * また、電話番号の入力に使用される可能性のある全角数字や記号を半角数字に変換し、不要な記号を削除します。\n * 電話番号データ（_pn_phoneNumberData関数内に格納）は、2025年10月1日現在の総務省の公開情報（https://www.soumu.go.jp/main_sosiki/joho_tsusin/top/tel_number/index.html）に基づいています。\n * なお、このプログラムは日本国内の利用者設備識別番号のうちIMSIを除いた番号に特化しており、国際電話番号には対応していません。\n *\n * エラーハンドリング:\n * - 無効な電話番号入力に対しては、throw new Error()で適切なエラーメッセージを投げます。\n * - 従来のnull返却ではなく、例外ベースのエラーハンドリングを採用しています。\n * - 使用時はtry-catch文でエラーをキャッチしてください。\n *\n * @author Shigeo Isshiki <issiki@kacsw.or.jp>\n * @version 1.0.0\n */\n// ==================== 電話番号データ定義ここから ====================\n/* exported _pn_fallbackFormatPhoneNumber, phone_number_formatting_with_type */\n// ※この部分は総務省の最新データに合わせて随時差し替えてください\nconst _pn_phoneNumberData = {\n  // 市外局番ごとの市内局番（もしくは局番）の桁数リスト\n  areaCodeList: {\n    5: {\n      '01267': 1,\n      '01372': 1,\n      '01374': 1,\n      '01377': 1,\n      '01392': 1,\n      '01397': 1,\n      '01398': 1,\n      '01456': 1,\n      '01457': 1,\n      '01466': 1,\n      '01547': 1,\n      '01558': 1,\n      '01564': 1,\n      '01586': 1,\n      '01587': 1,\n      '01632': 1,\n      '01634': 1,\n      '01635': 1,\n      '01648': 1,\n      '01654': 1,\n      '01655': 1,\n      '01656': 1,\n      '01658': 1,\n      '04992': 1,\n      '04994': 1,\n      '04996': 1,\n      '04998': 1,\n      '05769': 1,\n      '05979': 1,\n      '07468': 1,\n      '08512': 1,\n      '08514': 1,\n      '08477': 1,\n      '08387': 1,\n      '08388': 1,\n      '08396': 1,\n      '09802': 1,\n      '09912': 1,\n      '09913': 1,\n      '09969': 1,\n    },\n    4: {\n      '0123': 2,\n      '0124': 2,\n      '0125': 2,\n      '0126': 2,\n      '0133': 2,\n      '0134': 2,\n      '0135': 2,\n      '0136': 2,\n      '0137': 2,\n      '0138': 2,\n      '0139': 2,\n      '0142': 2,\n      '0143': 2,\n      '0144': 2,\n      '0145': 2,\n      '0146': 2,\n      '0152': 2,\n      '0153': 2,\n      '0154': 2,\n      '0155': 2,\n      '0156': 2,\n      '0157': 2,\n      '0158': 2,\n      '0162': 2,\n      '0163': 2,\n      '0164': 2,\n      '0165': 2,\n      '0166': 2,\n      '0167': 2,\n      '0172': 2,\n      '0173': 2,\n      '0174': 2,\n      '0175': 2,\n      '0176': 2,\n      '0178': 2,\n      '0179': 2,\n      '0182': 2,\n      '0183': 2,\n      '0184': 2,\n      '0185': 2,\n      '0186': 2,\n      '0187': 2,\n      '0191': 2,\n      '0192': 2,\n      '0193': 2,\n      '0194': 2,\n      '0195': 2,\n      '0197': 2,\n      '0198': 2,\n      '0220': 2,\n      '0223': 2,\n      '0224': 2,\n      '0225': 2,\n      '0226': 2,\n      '0228': 2,\n      '0229': 2,\n      '0233': 2,\n      '0234': 2,\n      '0235': 2,\n      '0237': 2,\n      '0238': 2,\n      '0240': 2,\n      '0241': 2,\n      '0242': 2,\n      '0243': 2,\n      '0244': 2,\n      '0246': 2,\n      '0247': 2,\n      '0248': 2,\n      '0250': 2,\n      '0254': 2,\n      '0255': 2,\n      '0256': 2,\n      '0257': 2,\n      '0258': 2,\n      '0259': 2,\n      '0260': 2,\n      '0261': 2,\n      '0263': 2,\n      '0264': 2,\n      '0265': 2,\n      '0266': 2,\n      '0267': 2,\n      '0268': 2,\n      '0269': 2,\n      '0270': 2,\n      '0274': 2,\n      '0276': 2,\n      '0277': 2,\n      '0278': 2,\n      '0279': 2,\n      '0280': 2,\n      '0282': 2,\n      '0283': 2,\n      '0284': 2,\n      '0285': 2,\n      '0287': 2,\n      '0288': 2,\n      '0289': 2,\n      '0291': 2,\n      '0293': 2,\n      '0294': 2,\n      '0295': 2,\n      '0296': 2,\n      '0297': 2,\n      '0299': 2,\n      '0422': 2,\n      '0428': 2,\n      '0436': 2,\n      '0438': 2,\n      '0439': 2,\n      '0460': 2,\n      '0463': 2,\n      '0465': 2,\n      '0466': 2,\n      '0467': 2,\n      '0470': 2,\n      '0475': 2,\n      '0476': 2,\n      '0478': 2,\n      '0479': 2,\n      '0480': 2,\n      '0493': 2,\n      '0494': 2,\n      '0495': 2,\n      '0531': 2,\n      '0532': 2,\n      '0533': 2,\n      '0536': 2,\n      '0537': 2,\n      '0538': 2,\n      '0539': 2,\n      '0544': 2,\n      '0545': 2,\n      '0547': 2,\n      '0548': 2,\n      '0550': 2,\n      '0551': 2,\n      '0553': 2,\n      '0554': 2,\n      '0555': 2,\n      '0556': 2,\n      '0557': 2,\n      '0558': 2,\n      '0561': 2,\n      '0562': 2,\n      '0563': 2,\n      '0564': 2,\n      '0565': 2,\n      '0566': 2,\n      '0567': 2,\n      '0568': 2,\n      '0569': 2,\n      '0572': 2,\n      '0573': 2,\n      '0574': 2,\n      '0575': 2,\n      '0576': 2,\n      '0577': 2,\n      '0578': 2,\n      '0581': 2,\n      '0584': 2,\n      '0585': 2,\n      '0586': 2,\n      '0587': 2,\n      '0594': 2,\n      '0595': 2,\n      '0596': 2,\n      '0597': 2,\n      '0598': 2,\n      '0599': 2,\n      '0721': 2,\n      '0725': 2,\n      '0735': 2,\n      '0736': 2,\n      '0737': 2,\n      '0738': 2,\n      '0739': 2,\n      '0740': 2,\n      '0742': 2,\n      '0743': 2,\n      '0744': 2,\n      '0745': 2,\n      '0746': 2,\n      '0747': 2,\n      '0748': 2,\n      '0749': 2,\n      '0761': 2,\n      '0763': 2,\n      '0765': 2,\n      '0766': 2,\n      '0767': 2,\n      '0768': 2,\n      '0770': 2,\n      '0771': 2,\n      '0772': 2,\n      '0773': 2,\n      '0774': 2,\n      '0776': 2,\n      '0778': 2,\n      '0779': 2,\n      '0790': 2,\n      '0791': 2,\n      '0794': 2,\n      '0795': 2,\n      '0796': 2,\n      '0797': 2,\n      '0798': 2,\n      '0799': 2,\n      '0820': 2,\n      '0823': 2,\n      '0824': 2,\n      '0826': 2,\n      '0827': 2,\n      '0829': 2,\n      '0833': 2,\n      '0834': 2,\n      '0835': 2,\n      '0836': 2,\n      '0837': 2,\n      '0838': 2,\n      '0845': 2,\n      '0846': 2,\n      '0847': 2,\n      '0848': 2,\n      '0852': 2,\n      '0853': 2,\n      '0854': 2,\n      '0855': 2,\n      '0856': 2,\n      '0857': 2,\n      '0858': 2,\n      '0859': 2,\n      '0863': 2,\n      '0865': 2,\n      '0866': 2,\n      '0867': 2,\n      '0868': 2,\n      '0869': 2,\n      '0875': 2,\n      '0877': 2,\n      '0879': 2,\n      '0880': 2,\n      '0883': 2,\n      '0884': 2,\n      '0885': 2,\n      '0887': 2,\n      '0889': 2,\n      '0892': 2,\n      '0893': 2,\n      '0894': 2,\n      '0895': 2,\n      '0896': 2,\n      '0897': 2,\n      '0898': 2,\n      '0920': 2,\n      '0930': 2,\n      '0940': 2,\n      '0942': 2,\n      '0943': 2,\n      '0944': 2,\n      '0946': 2,\n      '0947': 2,\n      '0948': 2,\n      '0949': 2,\n      '0950': 2,\n      '0952': 2,\n      '0954': 2,\n      '0955': 2,\n      '0956': 2,\n      '0957': 2,\n      '0959': 2,\n      '0964': 2,\n      '0965': 2,\n      '0966': 2,\n      '0967': 2,\n      '0968': 2,\n      '0969': 2,\n      '0972': 2,\n      '0973': 2,\n      '0974': 2,\n      '0977': 2,\n      '0978': 2,\n      '0979': 2,\n      '0980': 2,\n      '0982': 2,\n      '0983': 2,\n      '0984': 2,\n      '0985': 2,\n      '0986': 2,\n      '0987': 2,\n      '0993': 2,\n      '0994': 2,\n      '0995': 2,\n      '0996': 2,\n      '0997': 2,\n      '0120': 3,\n      '0800': 3,\n      '0170': 3,\n      '0180': 3,\n      '0570': 3,\n      '0990': 3,\n      '0200': 5,\n      '0204': 3,\n      '0600': 3,\n    },\n    3: {\n      '011': 3,\n      '015': 3,\n      '017': 3,\n      '018': 3,\n      '019': 3,\n      '022': 3,\n      '023': 3,\n      '024': 3,\n      '025': 3,\n      '026': 3,\n      '027': 3,\n      '028': 3,\n      '029': 3,\n      '042': 3,\n      '043': 3,\n      '044': 3,\n      '045': 3,\n      '046': 3,\n      '047': 3,\n      '048': 3,\n      '049': 3,\n      '052': 3,\n      '053': 3,\n      '054': 3,\n      '055': 3,\n      '058': 3,\n      '059': 3,\n      '072': 3,\n      '073': 3,\n      '075': 3,\n      '076': 3,\n      '077': 3,\n      '078': 3,\n      '079': 3,\n      '082': 3,\n      '083': 3,\n      '084': 3,\n      '086': 3,\n      '087': 3,\n      '088': 3,\n      '089': 3,\n      '092': 3,\n      '093': 3,\n      '095': 3,\n      '096': 3,\n      '097': 3,\n      '098': 3,\n      '099': 3,\n      '020': 3,\n      '060': 4,\n      '070': 4,\n      '080': 4,\n      '090': 4,\n      '050': 4,\n      '091': 3,\n    },\n    2: {\n      '03': 4,\n      '04': 4,\n      '06': 4,\n    },\n  },\n  // 電話番号市外局番ごとの市内局番（もしくは局番）の番号範囲リスト\n  // 市内局番（もしくは局番）の最初の2桁が範囲に含まれる場合、その市外局番を適用する\n  // 例：市外局番が0123の場合、市内局番の最初の2桁が20～50、52～60、62～70、72～80、82～99のいずれかに該当する場合に0123を適用\n  areaCodeRanges: {\n    '011': '200-899',\n    '0123': '20-50,52-60,62-70,72-80,82-99',\n    '0124': '20,22-39',\n    '0125': '20-99',\n    '0126': '20-60,62-69',\n    '01267': '2-9',\n    '0133': '20,22-39,60,62-79',\n    '0134': '20-99',\n    '0135': '20-49,60-79',\n    '0136': '20-79',\n    '01372': '2-9',\n    '01374': '2-9',\n    '0137': '50-60,62-69,80,82-89',\n    '01377': '2-9',\n    '0138': '20-99',\n    '01392': '2-9',\n    '0139': '30-40,42-50,52-60,62-69',\n    '01397': '2-9',\n    '01398': '2-9',\n    '0142': '20-99',\n    '0143': '20-99',\n    '0144': '20-99',\n    '0145': '20,22-40,42-59',\n    '01456': '2-9',\n    '01457': '2-9',\n    '0146': '20,22-30,32-40,42-59',\n    '01466': '2-9',\n    '0152': '20,22-70,72-89',\n    '0153': '20,22-50,52-70,72-80,82-99',\n    '015': '410-416,417-419,480,482-489,510-516,518-519,570,572-579',\n    '0154': '20-69,90-99',\n    '01547': '2-9',\n    '0155': '20-69,90-99',\n    '01558': '2-9',\n    '0156': '20,22-39,60,62-79',\n    '01564': '2-9',\n    '0157': '20-99',\n    '0158': '20,22-40,42-59,80,82-99',\n    '01586': '2-9',\n    '01587': '2-9',\n    '0162': '20-99',\n    '01632': '2-9',\n    '01634': '2-9',\n    '01635': '2-9',\n    '0163': '60,62-80,82-99',\n    '0164': '20,22-30,32-40,42-50,52-60,62-79',\n    '01648': '2-9',\n    '0165': '20,22-30,32-39',\n    '01654': '2-9',\n    '01655': '2-9',\n    '01656': '2-9',\n    '01658': '2-9',\n    '0166': '20-99',\n    '0167': '20-99',\n    '0172': '20-99',\n    '0173': '20-89',\n    '0174': '20-99',\n    '0175': '20-49,60-79',\n    '0176': '20-99',\n    '0177': '700-716,718-799',\n    '0178': '20-99',\n    '0179': '20-99',\n    '0182': '20-99',\n    '0183': '20-99',\n    '0184': '20-99',\n    '0185': '20-89',\n    '0186': '20-99',\n    '0187': '30-89',\n    '018': '800-899',\n    '0191': '20-99',\n    '0192': '20-99',\n    '0193': '20-99',\n    '0194': '20-79',\n    '0195': '20-89',\n    '0196': '600-616,618-699,900-929',\n    '0197': '20-89',\n    '0198': '20-49,60-79',\n    '0220': '20-99',\n    '022': '200-309,340-399,700-799',\n    '0223': '20-39',\n    '0224': '20-89',\n    '0225': '20-99',\n    '0226': '20-99',\n    '0228': '20-99',\n    '0229': '20-99',\n    '0233': '20-99',\n    '0234': '20-99',\n    '0235': '20-99',\n    '023': '600-616,618-699',\n    '0237': '20-89',\n    '0238': '20-99',\n    '0240': '20-49',\n    '0241': '20-76,78-99',\n    '0242': '20-99',\n    '0243': '20-99',\n    '0244': '20-99',\n    '0245': '500-516,518-599,900-916,918-999',\n    '0246': '20-99',\n    '0247': '20-89',\n    '0248': '20-99',\n    '0250': '20-99',\n    '025': '200-216,218-399,500-516,518-569,590,592-609,700-716,718-719,750-790,792-809',\n    '0254': '20-90,92-99',\n    '0255': '70-89',\n    '0256': '20-99',\n    '0257': '20-49',\n    '0258': '20-99',\n    '0259': '20-89',\n    '0260': '20-39',\n    '0261': '20-76,78-99',\n    '026': '200-299,400-409,460-499',\n    '0263': '20-99',\n    '0264': '20-59',\n    '0265': '20-99',\n    '0266': '20-99',\n    '0267': '20-99',\n    '0268': '20-99',\n    '0269': '20-89',\n    '0270': '20-99',\n    '027': '200-399,800-809,880-899',\n    '0274': '20-89',\n    '0276': '20-99',\n    '0277': '20-99',\n    '0278': '20-79',\n    '0279': '20-99',\n    '0280': '20-99',\n    '0282': '20-99',\n    '028': '300-309,330-349,600-699,900-909,920-959',\n    '0283': '20-29,50-99',\n    '0284': '20-99',\n    '0285': '20-99',\n    '0287': '20-99',\n    '0288': '20-99',\n    '0289': '60-99',\n    '0291': '30-49',\n    '029': '200-309,350-399,800-899',\n    '0293': '20-49',\n    '0294': '20-99',\n    '0295': '50-70,72-79',\n    '0296': '20-59,70-89',\n    '0297': '20-99',\n    '0299': '20-99',\n    '03': '3100-3999,4200-4599,5000-5999,6100-6999',\n    '04': '2000-2009,2900-2909,2920-2969,2990-2999,7000-7009,7090-7116,7118-7176,7178-7199',\n    '042':\n      '200-209,300-316,318-416,418-516,518-599,610-616,618-670,672-680,682-716,718-730,732-780,782-816,818-819,840-869,910-916,918-919,970-989',\n    '0422': '20-99',\n    '0428': '20-39,70-99',\n    '043': '200-499',\n    '0436': '20-99',\n    '0438': '20-99',\n    '0439': '20-99',\n    '044': '200-999',\n    '045': '200-999',\n    '0460': '80-89',\n    '046': '200-216,218-299,400-419,800-816,818-899',\n    '0463': '20-99',\n    '0465': '20-99',\n    '0466': '20-99',\n    '0467': '20-99',\n    '0470': '20-89',\n    '047': '300-499,700-729,750-779',\n    '0475': '20-89',\n    '0476': '20-99',\n    '0478': '50-89',\n    '0479': '20-89',\n    '0480': '20-99',\n    '048': '200-299,400-999',\n    '049': '200-299',\n    '0493': '20-99',\n    '0494': '20-99',\n    '0495': '20-99',\n    '04992': '2-9',\n    '04994': '2-9',\n    '04996': '2-9',\n    '04998': '2-9',\n    '052': '200-999',\n    '0531': '20-49',\n    '0532': '20-99',\n    '0533': '20-99',\n    '053': '400-599,920-959,964-973,975-976,978-989',\n    '0536': '20-39,60-89',\n    '0537': '20-99',\n    '0538': '20-99',\n    '0539': '60-63,74,77,90-99',\n    '054': '200-299,320-399,600-699,900-909',\n    '0556': '20-60,62-69',\n    '0544': '20-99',\n    '0545': '20-99',\n    '0547': '20-99',\n    '0548': '20-99',\n    '0550': '20-99',\n    '0551': '20-76,78-99',\n    '055': '200-216,218-299,900-916,918-999',\n    '0553': '20-99',\n    '0554': '20-99',\n    '0555': '20-99',\n    '0557': '20-99',\n    '0558': '20-99',\n    '0561': '20-76,78-99',\n    '0562': '20-99',\n    '0563': '20-99',\n    '0564': '20-99',\n    '0565': '20-99',\n    '0566': '20-99',\n    '0567': '20-99',\n    '0568': '20-99',\n    '0569': '20-99',\n    '0572': '20-99',\n    '0573': '20-89',\n    '0574': '20-89',\n    '0575': '20-89',\n    '0576': '20-89',\n    '05769': '2-9',\n    '0577': '20-99',\n    '0578': '70-89',\n    '0581': '20-76,78-99',\n    '058': '200-399',\n    '0584': '20-99',\n    '0585': '20-99',\n    '0586': '20-99',\n    '0587': '20-99',\n    '059': '200-299,310-399,990-999',\n    '0594': '20-99',\n    '0595': '20-99',\n    '0596': '20-79',\n    '0597': '20-39,42-49,70-90,97-98',\n    '05979': '2-6,9',\n    '0598': '20-89',\n    '0599': '20-89',\n    '06': '4100-4999,6100-6999,7100-7999',\n    '0721': '20-76,78-99',\n    '072': '200-499,600-999',\n    '0725': '20-99',\n    '073': '400-499',\n    '0735': '20-79',\n    '0736': '20-89',\n    '0737': '20-99',\n    '0738': '20-99',\n    '0739': '20-99',\n    '0740': '20-39',\n    '0742': '20-99',\n    '0743': '20-99',\n    '0744': '20-99',\n    '0745': '20-99',\n    '0746': '30-69',\n    '07468': '2-9',\n    '0747': '20-69',\n    '0748': '20-89',\n    '0749': '20-89',\n    '075': '200-999',\n    '0761': '20-84',\n    '076': '200-216,218-299,400-416,418-499',\n    '0763': '20-99',\n    '0765': '20-99',\n    '0766': '20-99',\n    '0767': '20-89',\n    '0768': '20-89',\n    '0770': '20-79',\n    '0771': '20-89',\n    '0772': '20-89',\n    '0773': '20-89',\n    '0774': '20-99',\n    '077': '500-516,518-599',\n    '0776': '20-99',\n    '0778': '20-99',\n    '0779': '60-71,77-89',\n    '078': '200-999',\n    '0790': '20-89',\n    '0791': '20-29,40-79',\n    '079': '200-339,400-409,420-459,490-509,550-569,590-609,660-679',\n    '0794': '60-89',\n    '0795': '20-49,70-89',\n    '0796': '20-59,80-99',\n    '0797': '20-99',\n    '0798': '20-99',\n    '0799': '20-89',\n    '0820': '20-89',\n    '082': '200-299,400-409,420-439,490-599,800-909,921-929,941-943,960-969,990-999',\n    '0823': '20-99',\n    '0824': '40-89',\n    '0826': '20-89',\n    '0827': '20-50,52-99',\n    '0829': '20,30-40,44-59,70-89',\n    '083': '220-299,600-609,766-768,770-789,900-950,952-960,963,966,970-999',\n    '0833': '20-99',\n    '0834': '20-99',\n    '0835': '20-99',\n    '0836': '20-99',\n    '0837': '20-65,69',\n    '0838': '20-59',\n    '08387': '2-9',\n    '08388': '2-9',\n    '08396': '2,4-5,7-9',\n    '0845': '20-39',\n    '0846': '20-49,60-79',\n    '0847': '20-69,80-99',\n    '08477': '2-9',\n    '0848': '20-99',\n    '084': '900-999',\n    '08512': '2-9',\n    '08514': '2-9',\n    '0852': '20-99',\n    '0853': '20-99',\n    '0854': '20-99',\n    '0855': '20-99',\n    '0856': '20-59,70-89',\n    '0857': '20-99',\n    '0858': '20-89',\n    '0859': '20-89',\n    '086':\n      '200-299,362-365,367-369,420-489,520-529,552-553,600-609,691,697-698,722-724,726,728,737-738,800-809,890-909,940-959,994-999',\n    '0863': '20-59,66,70-89',\n    '0865': '40-51,54-79',\n    '0866': '20-90,92-96,99',\n    '0867': '20-21,25,27,29-36,39-99',\n    '0868': '20-89',\n    '0869': '20-29,34,60-89,92-93',\n    '0875': '20-99',\n    '0877': '20-99',\n    '087': '800-899',\n    '0879': '20-89',\n    '0880': '20-99',\n    '0883': '20-89',\n    '0884': '20-89',\n    '0885': '30,32-40,42-49',\n    '088': '600-616,618-699,800-816,818-899',\n    '0887': '20,22-99',\n    '0889': '20-69',\n    '0892': '20-99',\n    '0893': '20-99',\n    '0894': '20-99',\n    '0895': '20-89',\n    '0896': '20-99',\n    '0897': '20-89',\n    '0898': '20-99',\n    '089': '900-999',\n    '0920': '40-59,80-89',\n    '092': '200-999',\n    '0930': '20-59',\n    '093': '200-999',\n    '0940': '20-99',\n    '0942': '20-99',\n    '0943': '20-59,70-89',\n    '0944': '20-99',\n    '0946': '20-99',\n    '0947': '20-99',\n    '0948': '20-99',\n    '0949': '20-59,62-69',\n    '0950': '20-99',\n    '0952': '20-99',\n    '0954': '20-49,60-79',\n    '0955': '20-89',\n    '0956': '20-99',\n    '0957': '20-89',\n    '095': '800-899',\n    '0959': '20-99',\n    '096': '200-399',\n    '0964': '20-99',\n    '0965': '20-99',\n    '0966': '20,22-89',\n    '0967': '20,22-99',\n    '0968': '20-89',\n    '0969': '20-89',\n    '0972': '20-89',\n    '0973': '20-59,70-89',\n    '0974': '20,22-49,60,62-79',\n    '097': '500-599',\n    '0977': '20-99',\n    '0978': '20,22-60,62-99',\n    '0979': '20-99',\n    '09802': '2-9',\n    '0980': '30-70,72-80,82-99',\n    '0982': '20-99',\n    '0983': '20-99',\n    '0984': '20-99',\n    '0985': '20-99',\n    '0986': '20-99',\n    '0987': '20-99',\n    '098': '800-999',\n    '09912': '2-9',\n    '09913': '2-9',\n    '099': '200-216,218-299,331,343,345,347,400-409,470-489,800-839',\n    '0993': '20-30,32-42,44,46,48-89',\n    '0994': '20-69,90-99',\n    '0995': '20-79',\n    '0996': '20-89',\n    '09969': '2-9',\n    '0997': '20,22-99',\n    '0120': '0-999',\n    '0800': '0-999',\n    '0570': '0-999',\n    '0990': '0-999',\n    '020': '100-399,500-999',\n    '0200': '10000-10999',\n    '060': '1000-9999',\n    '070': '1000-9999',\n    '080': '1000-9999',\n    '090': '1000-9999',\n    '050': '1000-9999',\n  },\n  // 11桁の表記の電気通信番号の市外局番リスト\n  // これらの市外局番の場合、電話番号は11桁である必要がある\n  // 例：0800、020、060、070、080、090、0204、050、0600　'0800', '020', '060', '070', '080', '090', '0204', '050', '0600'\n  digit11PhoneNumberRange: {\n    service: ['0800'],\n    m2m: ['020'],\n    mobile: ['060', '070', '080', '090'],\n    wireless: ['0204'],\n    ipphone: ['050'],\n    fmc: ['0600'],\n  },\n  // 固定電話番号でない市外局番リスト\n  // これらの市外局番の場合、固定電話番号としてのチェックを行わない\n  // 例：0120、0170、0180、0570、0990\n  notLandlinePhoneNumberRange: ['0120', '0170', '0180', '0570', '0990'],\n};\n// ==================== 電話番号データ定義ここまで ====================\n// --- ここから下はロジック部分 ---\n// データ参照用関数やメイン処理など\n// データ参照用関数\nconst _pn_getAreaCodeInfo = (codeLength, code) => {\n  return _pn_phoneNumberData.areaCodeList[codeLength]?.[code];\n};\n// --- areaCodeListの降順キャッシュ ---\nlet _pn_areaCodeListCache = null;\nconst _pn_getAreaCodeList = () => {\n  if (_pn_areaCodeListCache) return _pn_areaCodeListCache;\n  _pn_areaCodeListCache = Object.keys(_pn_phoneNumberData.areaCodeList)\n    .map(Number)\n    .sort((a, b) => b - a);\n  return _pn_areaCodeListCache;\n};\n// 圧縮表現を配列に展開する関数\nconst _pn_expandRangeString = (rangeStr) => {\n  if (!rangeStr) return null;\n  return rangeStr.split(',').map((part) => {\n    if (part.includes('-')) {\n      const [start, end] = part.split('-').map(Number);\n      return [start, end];\n    } else {\n      const n = Number(part);\n      return [n, n];\n    }\n  });\n};\nconst _pn_getLocalAreaCodeRange = (code) => {\n  const val = _pn_phoneNumberData.areaCodeRanges[code];\n  if (!val) return undefined;\n  if (Array.isArray(val)) return val; // 旧形式も一応サポート\n  return _pn_expandRangeString(val);\n};\n// digit11PhoneNumberRange用途別リスト参照関数\nconst _pn_getDigit11PrefixList = (type) => {\n  return _pn_phoneNumberData.digit11PhoneNumberRange &&\n    _pn_phoneNumberData.digit11PhoneNumberRange[type]\n    ? _pn_phoneNumberData.digit11PhoneNumberRange[type]\n    : [];\n};\nconst _pn_isDigit11PhoneNumberRange = (code) => {\n  const allPrefixes = Object.values(_pn_phoneNumberData.digit11PhoneNumberRange).flat();\n  return allPrefixes.includes(code);\n};\nconst _pn_isNotLandlinePhoneNumberRange = (code) => {\n  return _pn_phoneNumberData.notLandlinePhoneNumberRange.includes(code);\n};\n// サブ処理\n// 正規表現の事前コンパイル\nconst _pn_removeSymbolsReg = /[()（）\\-‐－―—.．\\/／ 　]/g;\nconst _pn_zenkakuNumReg = /[０-９]/g;\n/**\n * 電話番号として処理できる数字のみの文字列に変換する関数（正規化）\n * @param {string|number|null|undefined} str - 入力された文字列\n * @returns {string} 電話番号として処理できる数字のみの文字列\n * @throws {Error} 入力が空または数字を含まない場合にエラーを投げる\n */\nconst _pn_getPhoneNumberOnly = (str) => {\n  if (!str) {\n    throw new Error('電話番号が入力されていません');\n  }\n  const result = String(str)\n    .replace(_pn_removeSymbolsReg, '') // 記号除去\n    .replace(_pn_zenkakuNumReg, (s) => String.fromCharCode(s.charCodeAt(0) - 0xfee0)); // 全角数字→半角\n\n  if (!result || !/^\\d+$/.test(result)) {\n    throw new Error(\n      `電話番号として無効です（数字以外の文字が含まれているか、数字が含まれていません）: ${str}`\n    );\n  }\n\n  return result;\n};\n/**\n * 電話番号の種別を判定する関数\n * @param {string|number|null|undefined} number - 入力された電話番号\n * @returns {string} 'landline' | 'mobile' | 'special' | 'unknown'\n * @throws {Error} 無効な入力の場合にエラーを投げる\n */\nconst _pn_getPhoneType = (number) => {\n  const num = _pn_getPhoneNumberOnly(number); // この時点でエラーが投げられる可能性あり\n\n  // 14桁番号のtype判定\n  if (num.length === 14) {\n    const prefix4 = num.substring(0, 4);\n    if (prefix4 === '0200') return 'm2m'; // 0200はM2M専用\n  }\n  // 11桁番号のtype判定（digit11PhoneNumberRangeの各typeに対応）\n  if (num.length === 11) {\n    // 4桁prefix優先\n    const prefix4 = num.substring(0, 4);\n    const prefix3 = num.substring(0, 3);\n    if (_pn_getDigit11PrefixList('service').includes(prefix4)) return 'service';\n    if (_pn_getDigit11PrefixList('wireless').includes(prefix4)) return 'wireless';\n    if (_pn_getDigit11PrefixList('fmc').includes(prefix4)) return 'fmc';\n    if (_pn_getDigit11PrefixList('m2m').includes(prefix3)) return 'm2m';\n    if (_pn_getDigit11PrefixList('m2m').includes(prefix4)) return 'm2m';\n    if (_pn_getDigit11PrefixList('mobile').includes(prefix3)) return 'mobile';\n    if (_pn_getDigit11PrefixList('ipphone').includes(prefix3)) return 'ipphone';\n  }\n  // 10桁特殊番号\n  if (num.length === 10 && _pn_isNotLandlinePhoneNumberRange(num.substring(0, 4))) {\n    return 'special';\n  }\n  if (num.length === 10) {\n    return 'landline';\n  }\n  return 'unknown';\n};\n/**\n * 電話番号の種別に応じたハイフンパターンを返す関数\n * @param {string|number|null|undefined} number - 入力された電話番号\n * @param {string} type - 電話番号種別\n * @returns {Array<number>} ハイフン位置の配列（例: [4,3,4]）\n */\nconst _pn_getHyphenPattern = (number, type) => {\n  const num = _pn_getPhoneNumberOnly(number);\n  if (!num) return [];\n  // 14桁の0200番号（M2M専用）は[4,5,5]で分割\n  if (num.length === 14 && num.startsWith('0200')) {\n    return [4, 5, 5];\n  }\n  // 11桁系番号\n  if (\n    type === 'mobile' ||\n    type === 'service' ||\n    type === 'm2m' ||\n    type === 'wireless' ||\n    type === 'fmc' ||\n    type === 'ipphone'\n  ) {\n    // 4桁prefix（例: 0800, 0204, 0600）は[4,3,4]、3桁prefixは[3,4,4]\n    if (num.length === 11 && _pn_isDigit11PhoneNumberRange(num.substring(0, 4))) {\n      return [4, 3, 4];\n    }\n    return [3, 4, 4];\n  }\n  if (type === 'special') {\n    // 例: 0120-123-456\n    return [4, 3, 3];\n  }\n  if (type === 'landline') {\n    // 市外局番・市内局番・加入者番号の長さを判定\n    const areaCodeList = _pn_getAreaCodeList();\n    for (let c = 0, l = areaCodeList.length; c < l; c++) {\n      let areaCodeLen = areaCodeList[c];\n      let areaCode = num.substring(0, areaCodeLen);\n      let localLen = _pn_getAreaCodeInfo(areaCodeLen, areaCode);\n      if (localLen) {\n        const subscriberLen = num.length - areaCodeLen - localLen;\n        return [areaCodeLen, localLen, subscriberLen];\n      }\n    }\n    // 該当しない場合\n    return [3, 3, 4];\n  }\n  return [];\n};\n/**\n * 電話番号を正規化し、ハイフン付きでフォーマットする関数\n * @param {string|number|null|undefined} str - 入力された電話番号\n * @returns {string} フォーマット済み電話番号\n * @throws {Error} 無効な電話番号の場合にエラーを投げる\n */\nconst _pn_formatPhoneNumber = (str) => {\n  const num = _pn_getPhoneNumberOnly(str); // この時点でエラーが投げられる可能性あり\n\n  // 091特殊番号は必ず091-以下全て\n  if (num.startsWith('091') && num.length >= 6 && num.length <= 13) {\n    return `${num.substring(0, 3)}-${num.substring(3)}`;\n  }\n  const type = _pn_getPhoneType(num);\n  const pattern = _pn_getHyphenPattern(num, type);\n  if (!pattern.length) return num;\n  let idx = 0;\n  const parts = pattern.map((len) => {\n    const part = num.substring(idx, idx + len);\n    idx += len;\n    return part;\n  });\n  return parts.filter(Boolean).join('-');\n};\n// --- 以下、フォールバック用のサブ関数群 ---\nconst _pn_is11DigitMobile = (num) => {\n  if (num.length !== 11) return false;\n  const code4 = num.substring(0, 4);\n  return _pn_isDigit11PhoneNumberRange(code4);\n};\nconst _pn_format11DigitMobile = (num) => {\n  const areaCodeList = _pn_getAreaCodeList();\n  for (let c = 0, l = areaCodeList.length; c < l; c++) {\n    let areaCodeLen = areaCodeList[c];\n    let telephoneNumberAreaCode = num.substring(0, areaCodeLen);\n    let localAreaCodeLen = _pn_getAreaCodeInfo(areaCodeLen, telephoneNumberAreaCode);\n    if (localAreaCodeLen && _pn_isDigit11PhoneNumberRange(telephoneNumberAreaCode)) {\n      const local_code = Number(num.substring(areaCodeLen, areaCodeLen + localAreaCodeLen));\n      const subscriber_number = num.substring(areaCodeLen + localAreaCodeLen);\n      return subscriber_number\n        ? `${telephoneNumberAreaCode}-${local_code}-${subscriber_number}`\n        : `${telephoneNumberAreaCode}-${local_code}`;\n    }\n  }\n  return num;\n};\nconst _pn_isSpecial14DigitNumber = (num) => {\n  return num.length === 14 && num.startsWith('0200');\n};\nconst _pn_is10DigitSpecial = (num) => {\n  if (num.length !== 10) return false;\n  const code4 = num.substring(0, 4);\n  return _pn_isNotLandlinePhoneNumberRange(code4);\n};\nconst _pn_is091SpecialNumber = (num) => {\n  return num.startsWith('091') && num.length >= 6 && num.length <= 13;\n};\nconst _pn_fallbackLandlineFormat = (num) => {\n  const areaCodeList = _pn_getAreaCodeList();\n  for (let c = 0, l = areaCodeList.length; c < l; c++) {\n    let areaCodeLen = areaCodeList[c];\n    let telephoneNumberAreaCode = num.substring(0, areaCodeLen);\n    let localAreaCodeLen = _pn_getAreaCodeInfo(areaCodeLen, telephoneNumberAreaCode);\n    if (localAreaCodeLen) {\n      let landlineFlag = !_pn_isNotLandlinePhoneNumberRange(telephoneNumberAreaCode);\n      let rejectFlag = false;\n      const local_code = Number(num.substring(areaCodeLen, areaCodeLen + localAreaCodeLen));\n      if (landlineFlag) {\n        if (Number(String(local_code).substring(0, 1)) <= 1) {\n          rejectFlag = true;\n        }\n        if (!rejectFlag) {\n          const range = _pn_getLocalAreaCodeRange(telephoneNumberAreaCode);\n          if (!range) {\n            rejectFlag = true;\n          } else {\n            rejectFlag = !range.some(([min, max]) => local_code >= min && local_code <= max);\n          }\n        }\n      } else {\n        const local_area_code_flag = _pn_getLocalAreaCodeRange(telephoneNumberAreaCode);\n        if (!local_area_code_flag) {\n          return num;\n        } else {\n          if (!local_area_code_flag.some(([min, max]) => local_code >= min && local_code <= max)) {\n            return num;\n          }\n        }\n      }\n      if (!rejectFlag) {\n        const subscriber_number = num.substring(areaCodeLen + localAreaCodeLen);\n        return subscriber_number\n          ? `${telephoneNumberAreaCode}-${local_code}-${subscriber_number}`\n          : `${telephoneNumberAreaCode}-${local_code}`;\n      }\n    }\n  }\n  return num;\n};\n/**\n * 日本国内用電話番号バリデーション関数\n * @param {string|number|null|undefined} str\n * @returns {boolean}\n */\nconst _pn_isValidJapanesePhoneNumber = (str) => {\n  if (!str) return false;\n  const s = String(str).trim();\n  // 国番号(+81)や+で始まるものはNG\n  if (s.startsWith('+') || s.startsWith('81')) return false;\n  // 記号・全角数字除去\n  const num = _pn_getPhoneNumberOnly(s);\n  if (!num) return false;\n  // 先頭0でなければNG\n  if (!num.startsWith('0')) return false;\n  // 0200で始まる場合は14桁以外NG（最優先）\n  if (num.startsWith('0200')) {\n    return num.length === 14;\n  }\n  // 11桁必要なprefixで10桁しかない場合はNG\n  if (num.length === 10) {\n    const prefix4 = num.substring(0, 4);\n    const prefix3 = num.substring(0, 3);\n    const digit11Prefixes = Object.values(_pn_phoneNumberData.digit11PhoneNumberRange).flat();\n    if (digit11Prefixes.includes(prefix4) || digit11Prefixes.includes(prefix3)) {\n      return false;\n    }\n    // 10桁は市外局番リストに該当しなければfalse\n    const areaCodeList = _pn_getAreaCodeList();\n    let found = false;\n    for (let c = 0, l = areaCodeList.length; c < l; c++) {\n      let areaCodeLen = areaCodeList[c];\n      let areaCode = num.substring(0, areaCodeLen);\n      if (_pn_getAreaCodeInfo(areaCodeLen, areaCode)) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) return false;\n    return true;\n  }\n  // 091で始まる6～13桁の特殊番号を許可\n  if (num.startsWith('091') && num.length >= 6 && num.length <= 13) return true;\n  // 11桁は携帯・PHS等のprefixのみ許可\n  if (num.length === 11) {\n    const prefix4 = num.substring(0, 4);\n    const prefix3 = num.substring(0, 3);\n    const digit11Prefixes = Object.values(_pn_phoneNumberData.digit11PhoneNumberRange).flat();\n    if (digit11Prefixes.includes(prefix4) || digit11Prefixes.includes(prefix3)) {\n      return true;\n    }\n    return false;\n  }\n  return false;\n};\n/**\n * フォールバック用の従来詳細ロジック\n * @param {string|number|null|undefined} telephoneNumber\n * @returns {string} フォーマット済み電話番号\n * @throws {Error} フォーマットに失敗した場合にエラーを投げる\n */\nconst _pn_fallbackFormatPhoneNumber = (telephoneNumber) => {\n  const telephoneNumberPNO = _pn_getPhoneNumberOnly(telephoneNumber); // この時点でエラーが投げられる可能性あり\n\n  // 11桁の携帯・PHS等\n  if (_pn_is11DigitMobile(telephoneNumberPNO)) {\n    return _pn_format11DigitMobile(telephoneNumberPNO);\n  }\n  // 14桁の特殊番号（0200...）\n  if (_pn_isSpecial14DigitNumber(telephoneNumberPNO)) {\n    return `${telephoneNumberPNO.substring(0, 4)}-${telephoneNumberPNO.substring(4, 9)}-${telephoneNumberPNO.substring(9)}`;\n  }\n  // notLandlinePhoneNumberRange（0120, 0800, 0570, 0990等）の特殊番号（10桁）\n  if (_pn_is10DigitSpecial(telephoneNumberPNO)) {\n    return `${telephoneNumberPNO.substring(0, 4)}-${telephoneNumberPNO.substring(4, 7)}-${telephoneNumberPNO.substring(7)}`;\n  }\n  // 091 の特殊番号（6～13桁）は091-以下全て\n  if (_pn_is091SpecialNumber(telephoneNumberPNO)) {\n    return `${telephoneNumberPNO.substring(0, 3)}-${telephoneNumberPNO.substring(3)}`;\n  }\n  // 10桁以外はそのまま返す\n  if (telephoneNumberPNO.length !== 10) {\n    return telephoneNumberPNO;\n  }\n  // 固定電話番号の詳細判定\n  return _pn_fallbackLandlineFormat(telephoneNumberPNO);\n};\n\n// メイン処理\n/**\n * 日本国内用バリデーションを強化した電話番号フォーマット関数\n * @param {string|number|null|undefined} telephoneNumber - 入力された電話番号\n * @returns {string} ハイフン位置を修正した電話番号\n * @throws {Error} 無効な電話番号の場合にエラーを投げる\n */\nconst phone_number_formatting = (telephoneNumber) => {\n  if (!telephoneNumber) {\n    throw new Error('電話番号が入力されていません');\n  }\n  // バリデーション\n  if (!_pn_isValidJapanesePhoneNumber(telephoneNumber)) {\n    throw new Error(`無効な日本国内電話番号です（桁数・形式が不正です）: ${telephoneNumber}`);\n  }\n  // 正規化\n  const num = _pn_getPhoneNumberOnly(telephoneNumber);\n  // 市外局番リスト取得（最長一致優先）\n  const areaCodeList = _pn_getAreaCodeList();\n  let found = false;\n  let matchedAreaCodeLen = null;\n  let matchedAreaCode = null;\n  let matchedLocalLen = null;\n  for (let c = 0, l = areaCodeList.length; c < l; c++) {\n    let areaCodeLen = areaCodeList[c];\n    let areaCode = num.substring(0, areaCodeLen);\n    let localLen = _pn_getAreaCodeInfo(areaCodeLen, areaCode);\n    if (localLen) {\n      matchedAreaCodeLen = areaCodeLen;\n      matchedAreaCode = areaCode;\n      matchedLocalLen = localLen;\n      found = true;\n      break;\n    }\n  }\n  if (!found) {\n    throw new Error(`無効な日本国内電話番号です（桁数・形式が不正です）: ${telephoneNumber}`);\n  }\n  // areaCodeRangesに範囲が定義されている場合は必ず範囲チェック\n  const range = _pn_getLocalAreaCodeRange(matchedAreaCode);\n  if (range) {\n    const local_code_str = num.substring(matchedAreaCodeLen, matchedAreaCodeLen + matchedLocalLen);\n    const padLen = local_code_str.length;\n    if (\n      !range.some(([min, max]) => {\n        const minStr = String(min).padStart(padLen, '0');\n        const maxStr = String(max).padStart(padLen, '0');\n        return local_code_str >= minStr && local_code_str <= maxStr;\n      })\n    ) {\n      throw new Error(`無効な日本国内電話番号です（桁数・形式が不正です）: ${telephoneNumber}`);\n    }\n  }\n  // ここまでバリデーションを通過した場合のみフォーマット\n  const formatted = _pn_formatPhoneNumber(telephoneNumber);\n  return formatted;\n};\n\n/**\n * フォーマット済み電話番号と携帯判定を返す拡張関数\n * @param {string|number|null|undefined} telephoneNumber\n * @returns {{ formatted: string, isMobile: boolean, type: string }}\n * @throws {Error} 無効な電話番号の場合にエラーを投げる\n */\nconst phone_number_formatting_with_type = (telephoneNumber) => {\n  const formatted = phone_number_formatting(telephoneNumber); // この時点でエラーが投げられる可能性あり\n  const num = _pn_getPhoneNumberOnly(telephoneNumber);\n  const type = _pn_getPhoneType(num);\n  return {\n    formatted,\n    isMobile: type === 'mobile',\n    // type: 'mobile', 'service', 'm2m', 'wireless', 'fmc', 'ipphone', 'landline', 'special', 'unknown'\n    type,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/issiki_sigeo/Library/CloudStorage/OneDrive-公益社団法人神奈川県社会福祉士会/ドキュメント/kintone/アプリ開発/my-first-static-web-app/src/shipping-processing.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'_sp_checkBoolean' is assigned a value but never used.","line":37,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":37,"endColumn":23,"suggestions":[{"messageId":"removeVar","data":{"varName":"_sp_checkBoolean"},"fix":{"range":[1095,1168],"text":""},"desc":"Remove unused variable '_sp_checkBoolean'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** 郵便番号や電話番号処理を除いた運送会社に関する処理をまとめたJavaScriptの関数群です。\n * @author Shigeo Isshiki <issiki@kacsw.or.jp>\n * @version 1.0.0\n */\n// 関数命名ルール: 外部に見せる関数名はそのまま、内部で使用する関数名は(_sp_)で始める\n/* exported getNextBusinessDay, kintoneShippingInquiryButton, validateTrackingNumber, _sp_checkBoolean */\n'use strict';\n//　ライブラリ内の共通定数・変換テーブル定義部\n// 祝日APIベースURL\nconst _SP_HOLIDAY_API_BASE_URL = 'https://api.national-holidays.jp';\n\n// 運送会社ごとの問い合わせURLテンプレート\nconst _SP_SHIPPING_INQUIRY_URL_MAP = {\n  yamato: 'https://member.kms.kuronekoyamato.co.jp/parcel/detail?pno={trackingNumber}', // ヤマト運輸\n  japanpost:\n    'https://trackings.post.japanpost.jp/services/srv/search/direct?searchKind=S002&locale=ja&reqCodeNo1={trackingNumber}', // 日本郵便\n};\n\n// ハイフン類を検出するための正規表現（全角・半角・ダッシュ類）\nconst _SP_HYPHEN_REGEX = /[－‐‑–—−ー―]/g;\n\n//　ライブラリ内の共通関数定義部\n/**\n * 文字列が文字列型であることを確認する関数\n * @param {*} str 確認する文字列\n * @returns {boolean} 文字列である = true、文字でない = false\n */\nconst _sp_checkString = (str) => {\n  return typeof str === 'string';\n};\n\n/**\n * boolean型であることを確認する関数\n * @param {*} val 確認する値\n * @returns {boolean} boolean型である = true、そうでない = false\n */\nconst _sp_checkBoolean = (val) => {\n  return typeof val === 'boolean';\n};\n\n/**\n * 指定された日付が国民の祝日かどうかをWebAPIで判定する内部関数（コールバック形式）\n * @param {Date} date 判定対象の日付\n * @param {(isHoliday: boolean) => void} callback 判定結果を返すコールバック関数\n * @returns {void}\n */\nconst _sp_isNationalHolidayCallback = (date, callback) => {\n  // 1948年7月20日以前は祝日法制定前なので対象外\n  if (date < new Date(1948, 6, 20)) {\n    callback(false);\n    return;\n  }\n\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const day = String(date.getDate()).padStart(2, '0');\n  const dateStr = `${year}-${month}-${day}`;\n\n  fetch(`${_SP_HOLIDAY_API_BASE_URL}/${dateStr}`)\n    .then((response) => {\n      if (!response.ok) {\n        // 404などのエラーは祝日でないことを意味する\n        callback(false);\n        return;\n      }\n      return response.json();\n    })\n    .then((result) => {\n      // 祝日でない場合 { error: \"not_found\" }\n      if (result && typeof result === 'object') {\n        if (result.error === 'not_found') {\n          callback(false);\n          return;\n        }\n        // 祝日の場合 { date: \"2025-01-01\", name: \"元日\" }\n        if (typeof result.date === 'string' && typeof result.name === 'string') {\n          callback(true);\n          return;\n        }\n      }\n      callback(false);\n    })\n    .catch((_error) => {\n      // 通信エラーやAPI異常時は祝日でないものとして扱う\n      callback(false);\n    });\n};\n\n/**\n * 指定された日付が営業日（土日・祝日・年末年始を除く平日）かどうかを判定する内部関数（コールバック形式）\n * @param {Date} date 判定対象の日付\n * @param {(isBusinessDay: boolean) => void} callback 判定結果を返すコールバック関数\n * @returns {void}\n */\nconst _sp_isBusinessDayCallback = (date, callback) => {\n  const dayOfWeek = date.getDay(); // 0=日曜日, 6=土曜日\n  const month = date.getMonth() + 1; // 1-12月\n  const day = date.getDate();\n\n  // 土曜日または日曜日は営業日ではない\n  if (dayOfWeek === 0 || dayOfWeek === 6) {\n    callback(false);\n    return;\n  }\n\n  // 年末年始（12月29日〜1月4日）は営業日ではない\n  if ((month === 12 && day >= 29) || (month === 1 && day <= 4)) {\n    callback(false);\n    return;\n  }\n\n  // 国民の祝日は営業日ではない\n  _sp_isNationalHolidayCallback(date, (isHoliday) => {\n    if (isHoliday) {\n      callback(false);\n    } else {\n      callback(true);\n    }\n  });\n};\n\n//　ライブラリ本体部\n/**\n * 発送日として適切な営業日を取得する関数（コールバック形式）\n * 土曜日、日曜日、国民の祝日、年末年始（12月29日～1月4日）を除いた営業日を返す\n * cutoffHour以降の場合は翌営業日を返す（省略時は16時）\n * @param {Date|string} [baseDate=new Date()] 基準日時（省略時は現在日時、kintoneの日付・日時フィールド形式にも対応）\n * @param {number} [cutoffHour=16] 締め時刻（省略時は16）\n * @param {(businessDay: string) => void} callback 発送可能な営業日（YYYY-MM-DD形式）を返すコールバック関数\n * @returns {void}\n * @throws {Error} 不正な日付の場合は例外\n */\nconst getNextBusinessDay = (baseDate = new Date(), cutoffHour = 16, callback) => {\n  if (typeof callback !== 'function') {\n    throw new Error('callback は関数である必要があります');\n  }\n  // cutoffHourが文字列の場合も数値化して判定\n  const cutoffHourNum = Number(cutoffHour);\n  if (!Number.isInteger(cutoffHourNum) || cutoffHourNum < 0 || cutoffHourNum > 23) {\n    throw new Error('締め時刻は0～23の整数である必要があります');\n  }\n  let targetDate;\n  let hasTimeInfo = false;\n  // 文字列の場合はDateオブジェクトに変換\n  if (typeof baseDate === 'string') {\n    targetDate = new Date(baseDate);\n    // 文字列に時刻情報が含まれているか判定（\"T\"や空白区切りで時刻がある場合）\n    hasTimeInfo = /T\\d{2}:\\d{2}|\\d{2}:\\d{2}/.test(baseDate);\n  } else if (baseDate instanceof Date) {\n    targetDate = new Date(baseDate);\n    // Date型で時刻が0:0:0以外なら時刻情報あり\n    hasTimeInfo =\n      targetDate.getHours() !== 0 || targetDate.getMinutes() !== 0 || targetDate.getSeconds() !== 0;\n  } else {\n    throw new Error('基準日時は日付文字列、またはDate型である必要があります');\n  }\n  // 有効な日付かチェック\n  if (isNaN(targetDate.getTime())) {\n    throw new Error('基準日時は有効な日付である必要があります');\n  }\n  // 時刻情報がある場合のみcutoffHour判定\n  if (hasTimeInfo && targetDate.getHours() >= cutoffHourNum) {\n    targetDate.setDate(targetDate.getDate() + 1);\n  }\n  // 営業日を探す再帰関数\n  const findBusinessDay = () => {\n    _sp_isBusinessDayCallback(targetDate, (isBusinessDay) => {\n      if (isBusinessDay) {\n        // 営業日が見つかったので結果を返す\n        const year = targetDate.getFullYear();\n        const month = String(targetDate.getMonth() + 1).padStart(2, '0');\n        const day = String(targetDate.getDate()).padStart(2, '0');\n        callback(`${year}-${month}-${day}`);\n      } else {\n        // 営業日でない場合は翌日をチェック\n        targetDate.setDate(targetDate.getDate() + 1);\n        findBusinessDay();\n      }\n    });\n  };\n  findBusinessDay();\n};\n\n// 公開\nif (typeof window !== 'undefined') {\n  window.getNextBusinessDay = getNextBusinessDay;\n  window.kintoneShippingInquiryButton = kintoneShippingInquiryButton;\n  window.validateTrackingNumber = validateTrackingNumber;\n}\n\n/**\n * kintoneのスペースフィールドに荷物問い合わせボタンを追加・削除する関数\n *\n * @function\n * @param {string} spaceField - スペースフィールドのフィールドコード\n * @param {string} id - ボタン要素のID名（任意のもの）\n * @param {string|undefined|null} label - ボタンラベル（省略時はデフォルト文言）\n *   - 文字列: 指定ラベル\n *   - undefined: デフォルト文言（例: '荷物問い合わせ'）\n *   - null/空文字: ボタン非表示（削除）\n * @param {string} trackingNumber - 問い合わせ番号（伝票番号）\n * @param {('yamato'|'japanpost')} carrier - 運送会社（'yamato'または'japanpost'）\n * @returns {void}\n * @description labelの値により表示制御：\n *   - 文字列なら指定ラベルで表示\n *   - undefinedならデフォルト文言で表示\n *   - null/空文字ならボタン非表示（削除）\n *   ボタン押下時、公式サイト（ヤマト運輸・日本郵便）に遷移します。\n */\nconst kintoneShippingInquiryButton = (spaceField, id, label, trackingNumber, carrier) => {\n  if (\n    typeof spaceField !== 'string' ||\n    !spaceField.trim() ||\n    typeof id !== 'string' ||\n    !id.trim() ||\n    (label !== null && typeof label !== 'string' && typeof label !== 'undefined') ||\n    typeof trackingNumber !== 'string' ||\n    !trackingNumber.trim() ||\n    (carrier !== 'yamato' && carrier !== 'japanpost')\n  ) {\n    return;\n  }\n  // 既存ボタン削除\n  const buttonElementById = document.getElementById(id);\n  if (buttonElementById) {\n    buttonElementById.remove();\n  }\n  // URL生成関数\n  const getInquiryUrl = (carrier, trackingNumber) => {\n    const template = _SP_SHIPPING_INQUIRY_URL_MAP[carrier];\n    if (!template) return '';\n    return template.replace('{trackingNumber}', encodeURIComponent(trackingNumber));\n  };\n  let textContent = '';\n  if (label !== undefined && label !== null && label !== '') {\n    textContent = label;\n  } else if (label === undefined) {\n    // デフォルト文言\n    textContent = '荷物問い合わせ';\n  } else {\n    // 非表示\n    const spaceElement = kintone.app.record.getSpaceElement(spaceField);\n    if (spaceElement && spaceElement.parentNode) {\n      spaceElement.parentNode.style.display = 'none';\n    }\n    return;\n  }\n  // ボタン追加\n  const button = document.createElement('button');\n  button.id = id;\n  button.textContent = textContent;\n  button.addEventListener('click', () => {\n    const url = getInquiryUrl(carrier, trackingNumber);\n    if (url) window.open(url, '_blank');\n  });\n  const spaceElement = kintone.app.record.getSpaceElement(spaceField);\n  if (spaceElement) {\n    spaceElement.appendChild(button);\n    spaceElement.parentNode.style.display = '';\n  }\n  return;\n};\n\n/**\n * 運送会社の伝票番号を半角数字のみに変換し、正しい形式かどうかを判定する関数\n * 全角・半角を問わず数字とハイフン・空白を許容し、最終的に半角数字のみの形式に変換する\n * 日本郵便・ヤマト運輸・佐川急便の伝票番号形式に対応\n * @param {string} trackingNumber チェック対象の伝票番号\n * @param {number} [minLength=10] 最小桁数（省略時は10桁、日本の主要3社対応）\n * @param {number} [maxLength=14] 最大桁数（省略時は14桁、日本の主要3社対応）\n * @returns {string} 変換後の伝票番号（半角数字のみ）\n * @throws {Error} 不正な場合は例外\n */\nconst validateTrackingNumber = (trackingNumber, minLength = 10, maxLength = 14) => {\n  if (!_sp_checkString(trackingNumber)) throw new Error('伝票番号は文字列である必要があります');\n  if (!Number.isInteger(minLength) || minLength < 1)\n    throw new Error('最小桁数は1以上の整数である必要があります');\n  if (!Number.isInteger(maxLength) || maxLength < minLength)\n    throw new Error('最大桁数は最小桁数以上の整数である必要があります');\n  if (!trackingNumber.trim()) throw new Error('伝票番号が空です');\n  // ハイフン類を統一し、全角文字を半角に変換\n  let processed = trackingNumber.replace(_SP_HYPHEN_REGEX, '-');\n  processed = processed.replace(/[０-９]/g, (s) => String.fromCharCode(s.charCodeAt(0) - 0xfee0));\n  processed = processed.replace(/\\u3000/g, ' '); // 全角スペースを半角に\n  // タブ・改行・復帰コードなども半角スペースに統一\n  processed = processed.replace(/[\\t\\n\\r]/g, ' ');\n  // 半角数字・ハイフン・空白以外が含まれていればエラー\n  if (!/^[0-9\\- ]+$/.test(processed)) {\n    const invalid = processed.match(/[^0-9\\- ]/)[0];\n    throw new Error(`伝票番号には半角数字・ハイフン・空白のみ許容されます。不正な文字: ${invalid}`);\n  }\n  // ハイフンと空白を除去して数字のみにする\n  const digitsOnly = processed.replace(/[\\- ]/g, '');\n  // 桁数チェック\n  if (digitsOnly.length < minLength || digitsOnly.length > maxLength) {\n    throw new Error(\n      `伝票番号は${minLength}桁以上${maxLength}桁以下の数字である必要があります（現在: ${digitsOnly.length}桁）`\n    );\n  }\n  return digitsOnly;\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/issiki_sigeo/Library/CloudStorage/OneDrive-公益社団法人神奈川県社会福祉士会/ドキュメント/kintone/アプリ開発/my-first-static-web-app/src/text-suite.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'_ts_replace_with_map' is assigned a value but never used.","line":266,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":266,"endColumn":27,"suggestions":[{"messageId":"removeVar","data":{"varName":"_ts_replace_with_map"},"fix":{"range":[5158,5522],"text":""},"desc":"Remove unused variable '_ts_replace_with_map'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'_old_check_single_byte_numbers' is assigned a value but never used.","line":279,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":279,"endColumn":37,"suggestions":[{"messageId":"removeVar","data":{"varName":"_old_check_single_byte_numbers"},"fix":{"range":[5640,5892],"text":""},"desc":"Remove unused variable '_old_check_single_byte_numbers'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'_old_check_single_byte_kana' is assigned a value but never used.","line":291,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":291,"endColumn":34,"suggestions":[{"messageId":"removeVar","data":{"varName":"_old_check_single_byte_kana"},"fix":{"range":[6019,6194],"text":""},"desc":"Remove unused variable '_old_check_single_byte_kana'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'_e' is defined but never used.","line":367,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":367,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** 文字列処理をまとめたJavaScriptの関数群です。\n * @author Shigeo Isshiki <issiki@kacsw.or.jp>\n * @version 1.0.0\n */\n// 関数命名ルール: 外部に見せる関数名はそのまま、内部で使用する関数名は(_ts_)で始める\n/* exported isSingleByteAlnumOnly, toFullWidthKatakana, toFullWidth, toFullWidthHiragana, toHalfWidthKana, toHalfWidth, assertEmailAddress, _ts_replace_with_map, _old_check_single_byte_numbers, _old_check_single_byte_kana */\n'use strict';\n//　ライブラリ内の共通定数・変換テーブル定義部\n// ハイフン類を検出するための正規表現（全角・半角・ダッシュ類）\nconst _TS_HYPHEN_REGEX = /[－‐‑–—−ー―]/g;\n\n/**\n * 変換用の文字リスト\n * 各種文字の変換ルールを定義します。\n * ひらがな、カタカナ、濁点・半濁点の変換をサポートします。\n * @typedef {object} _TS_CONVERT_CHARACTER_LIST\n * @property {object} halfWidthKana 全角カタカナから半角カタカナへの変換マップ\n * @property {object} fullWidthKana 半角カタカナから全角カタカナへの変換マップ\n * @property {object} turbidityKana 濁点・半濁点の変換マップ\n */\n/** @type {_TS_CONVERT_CHARACTER_LIST} */\nconst _TS_CONVERT_CHARACTER_LIST = {\n  halfWidthKana: {\n    ア: 'ｱ',\n    イ: 'ｲ',\n    ウ: 'ｳ',\n    エ: 'ｴ',\n    オ: 'ｵ',\n    カ: 'ｶ',\n    キ: 'ｷ',\n    ク: 'ｸ',\n    ケ: 'ｹ',\n    コ: 'ｺ',\n    サ: 'ｻ',\n    シ: 'ｼ',\n    ス: 'ｽ',\n    セ: 'ｾ',\n    ソ: 'ｿ',\n    タ: 'ﾀ',\n    チ: 'ﾁ',\n    ツ: 'ﾂ',\n    テ: 'ﾃ',\n    ト: 'ﾄ',\n    ナ: 'ﾅ',\n    ニ: 'ﾆ',\n    ヌ: 'ﾇ',\n    ネ: 'ﾈ',\n    ノ: 'ﾉ',\n    ハ: 'ﾊ',\n    ヒ: 'ﾋ',\n    フ: 'ﾌ',\n    ヘ: 'ﾍ',\n    ホ: 'ﾎ',\n    マ: 'ﾏ',\n    ミ: 'ﾐ',\n    ム: 'ﾑ',\n    メ: 'ﾒ',\n    モ: 'ﾓ',\n    ヤ: 'ﾔ',\n    ユ: 'ﾕ',\n    ヨ: 'ﾖ',\n    ラ: 'ﾗ',\n    リ: 'ﾘ',\n    ル: 'ﾙ',\n    レ: 'ﾚ',\n    ロ: 'ﾛ',\n    ワ: 'ﾜ',\n    ヲ: 'ｦ',\n    ン: 'ﾝ',\n    ガ: 'ｶﾞ',\n    ギ: 'ｷﾞ',\n    グ: 'ｸﾞ',\n    ゲ: 'ｹﾞ',\n    ゴ: 'ｺﾞ',\n    ザ: 'ｻﾞ',\n    ジ: 'ｼﾞ',\n    ズ: 'ｽﾞ',\n    ゼ: 'ｾﾞ',\n    ゾ: 'ｿﾞ',\n    ダ: 'ﾀﾞ',\n    ヂ: 'ﾁﾞ',\n    ヅ: 'ﾂﾞ',\n    デ: 'ﾃﾞ',\n    ド: 'ﾄﾞ',\n    バ: 'ﾊﾞ',\n    ビ: 'ﾋﾞ',\n    ブ: 'ﾌﾞ',\n    ベ: 'ﾍﾞ',\n    ボ: 'ﾎﾞ',\n    パ: 'ﾊﾟ',\n    ピ: 'ﾋﾟ',\n    プ: 'ﾌﾟ',\n    ペ: 'ﾍﾟ',\n    ポ: 'ﾎﾟ',\n    ヴ: 'ｳﾞ',\n    ヷ: 'ﾜﾞ',\n    ヺ: 'ｦﾞ',\n    ァ: 'ｧ',\n    ィ: 'ｨ',\n    ゥ: 'ｩ',\n    ェ: 'ｪ',\n    ォ: 'ｫ',\n    ッ: 'ｯ',\n    ャ: 'ｬ',\n    ュ: 'ｭ',\n    ョ: 'ｮ',\n    '゛': 'ﾞ',\n    '゜': 'ﾟ',\n    '　': ' ',\n  },\n  fullWidthKana: {\n    ｱ: 'ア',\n    ｲ: 'イ',\n    ｳ: 'ウ',\n    ｴ: 'エ',\n    ｵ: 'オ',\n    ｶ: 'カ',\n    ｷ: 'キ',\n    ｸ: 'ク',\n    ｹ: 'ケ',\n    ｺ: 'コ',\n    ｻ: 'サ',\n    ｼ: 'シ',\n    ｽ: 'ス',\n    ｾ: 'セ',\n    ｿ: 'ソ',\n    ﾀ: 'タ',\n    ﾁ: 'チ',\n    ﾂ: 'ツ',\n    ﾃ: 'テ',\n    ﾄ: 'ト',\n    ﾅ: 'ナ',\n    ﾆ: 'ニ',\n    ﾇ: 'ヌ',\n    ﾈ: 'ネ',\n    ﾉ: 'ノ',\n    ﾊ: 'ハ',\n    ﾋ: 'ヒ',\n    ﾌ: 'フ',\n    ﾍ: 'ヘ',\n    ﾎ: 'ホ',\n    ﾏ: 'マ',\n    ﾐ: 'ミ',\n    ﾑ: 'ム',\n    ﾒ: 'メ',\n    ﾓ: 'モ',\n    ﾔ: 'ヤ',\n    ﾕ: 'ユ',\n    ﾖ: 'ヨ',\n    ﾗ: 'ラ',\n    ﾘ: 'リ',\n    ﾙ: 'ル',\n    ﾚ: 'レ',\n    ﾛ: 'ロ',\n    ﾜ: 'ワ',\n    ｦ: 'ヲ',\n    ﾝ: 'ン',\n    ｧ: 'ァ',\n    ｨ: 'ィ',\n    ｩ: 'ゥ',\n    ｪ: 'ェ',\n    ｫ: 'ォ',\n    ｯ: 'ッ',\n    ｬ: 'ャ',\n    ｭ: 'ュ',\n    ｮ: 'ョ',\n    ﾞ: '゛',\n    ﾟ: '゜',\n    ' ': '　',\n  },\n  turbidityKana: {\n    'カ゛': 'ガ',\n    'キ゛': 'ギ',\n    'ク゛': 'グ',\n    'ケ゛': 'ゲ',\n    'コ゛': 'ゴ',\n    'サ゛': 'ザ',\n    'シ゛': 'ジ',\n    'ス゛': 'ズ',\n    'セ゛': 'ゼ',\n    'ソ゛': 'ゾ',\n    'タ゛': 'ダ',\n    'チ゛': 'ヂ',\n    'ツ゛': 'ヅ',\n    'テ゛': 'デ',\n    'ト゛': 'ド',\n    'ハ゛': 'バ',\n    'ヒ゛': 'ビ',\n    'フ゛': 'ブ',\n    'ヘ゛': 'ベ',\n    'ホ゛': 'ボ',\n    'ハ゜': 'パ',\n    'ヒ゜': 'ピ',\n    'フ゜': 'プ',\n    'ヘ゜': 'ペ',\n    'ホ゜': 'ポ',\n    'ウ゛': 'ヴ',\n    'ワ゛': 'ヷ',\n    'ヲ゛': 'ヺ',\n  },\n};\n// 全角カタカナから半角カタカナへの変換テーブルから生成するマップ（各種変換処理で利用）\nconst _TS_HALF_WIDTH_KANA_MAP = new Map(Object.entries(_TS_CONVERT_CHARACTER_LIST.halfWidthKana));\n// 半角カタカナから全角カタカナへの変換テーブルから生成するマップ（各種変換処理で利用）\nconst _TS_FULL_WIDTH_KANA_MAP = new Map(Object.entries(_TS_CONVERT_CHARACTER_LIST.fullWidthKana));\n// 濁点・半濁点の変換テーブルから生成するマップ（各種変換処理で利用）\nconst _TS_TURBIDITY_KANA_MAP = new Map(Object.entries(_TS_CONVERT_CHARACTER_LIST.turbidityKana));\n\n//　ライブラリ内の共通関数定義部\n/**\n * 文字列が文字列型であることを確認する関数\n * @param {*} str 確認する文字列\n * @returns {boolean} 文字列である = true、文字でない = false\n */\nconst _ts_checkString = (str) => {\n  return typeof str === 'string';\n};\n\n/**\n * boolean型であることを確認する関数\n * @param {*} val 確認する値\n * @returns {boolean} boolean型である = true、そうでない = false\n */\nconst _ts_checkBoolean = (val) => {\n  return typeof val === 'boolean';\n};\n\n/**\n * イテラブルな文字列集合から正規表現パターンを構築する関数\n * @param {Iterable<string>} keys イテラブルな文字列集合\n * @returns {RegExp} 正規表現のパターン\n */\nconst _ts_buildPattern = (keys) => {\n  if (!keys) throw new Error('keys is required');\n  const escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  if (!(keys && typeof keys[Symbol.iterator] === 'function'))\n    throw new Error('keys must be an Iterable');\n  const escapedKeys = [...keys].map(escapeRegExp);\n  return new RegExp(escapedKeys.join('|'), 'g');\n};\n\n/**\n * 指定した1文字が全角（漢字・ひらがな・カタカナ・全角記号等）かどうかを判定する関数\n * @param {string} char 判定対象の1文字\n * @returns {boolean} 全角文字ならtrue、そうでなければfalse\n */\nconst _ts_isFullWidthChar = (char) => {\n  if (!_ts_checkString(char) || char.length !== 1) return false;\n  const code = char.charCodeAt(0);\n  return (\n    (code >= 0x4e00 && code <= 0x9fff) || // 漢字\n    (code >= 0x3040 && code <= 0x309f) || // ひらがな\n    (code >= 0x30a0 && code <= 0x30ff) || // カタカナ\n    (code >= 0xff00 && code <= 0xff60) || // 全角記号・英数字・スペースなど\n    (code >= 0xffa0 && code <= 0xffef) // 全角記号など\n  );\n};\n\n/**\n * 文字列を正規表現で表記されたパターンに一致した場合、マップにある文字列に置き換える処理をする関数\n * @param {string} str 変換対象の文字列\n * @param {RegExp} pattern 正規表現のパターン\n * @param {Map} map 置き換えマップ\n * @returns {string} 置き換え後の文字列\n */\nconst _ts_replace_with_map = (str, pattern, map) => {\n  if (!_ts_checkString(str))\n    throw new Error(`_ts_replace_with_mapの[${str}]は文字である必要があります`);\n  if (!(pattern instanceof RegExp)) throw new Error('pattern must be a RegExp');\n  if (!(map instanceof Map)) throw new Error('map must be a Map');\n  return str.replace(pattern, (char) => map.get(char) ?? char);\n};\n\n/**\n * 文字列が半角数字のみ含まれるかをチェックする関数\n * @param {*} str チェック対象の文字列\n * @returns {boolean} 半角数字のみ含まれる場合はtrue、それ以外はfalse\n */\nconst _old_check_single_byte_numbers = (str = '') => {\n  if ((typeof str !== 'string' && typeof str !== 'number') || str === null || str === undefined)\n    return false;\n  const number_pattern = /^[0-9]+$/;\n  return number_pattern.test(String(str));\n};\n\n/**\n * 文字列が半角カナ文字のみ含まれるかをチェックする関数\n * @param {string} str チェック対象の文字列\n * @returns {boolean} 半角カナ文字のみ含まれる場合はtrue、それ以外はfalse\n */\nconst _old_check_single_byte_kana = (str = '') => {\n  if (!_ts_checkString(str)) return false;\n  const kana_pattern = /^[\\uFF61-\\uFF9F]+$/;\n  return kana_pattern.test(str);\n};\n\n//　ライブラリ本体部\n/**\n * 文字列が半角英数字・記号・スペースのみで構成されているかチェックする関数\n * @param {string} str チェック対象の文字列\n * @returns {boolean} 半角英数字・記号・スペースのみならtrue、それ以外はfalse\n */\nconst isSingleByteAlnumOnly = (str = '') => {\n  if (!_ts_checkString(str)) return false;\n  // 半角英数字・記号・スペースのみ\n  const pattern = /^[\\x20-\\x7E]*$/;\n  return pattern.test(str);\n};\n\n/**\n * 文字列を全角カタカナに変換する関数\n * @param {string} str 変換対象の文字列\n * @param {boolean} [throwOnError=true] 変換不能な文字があった場合にエラーを投げるかどうか\n * @returns {string} 可能な限り全角カタカナに変換した文字列\n * @throws {Error} 変換不能な文字が含まれている場合（throwOnError=true時）\n */\nconst toFullWidthKatakana = (str = '', throwOnError = true) => {\n  if (!_ts_checkString(str)) throw new Error('変換対象は文字列である必要があります');\n  if (!_ts_checkBoolean(throwOnError))\n    throw new Error('throwOnErrorはboolean型である必要があります');\n  if (!str) throw new Error('変換対象の文字列が空です');\n  const fullWidthKanaPattern = _ts_buildPattern(_TS_FULL_WIDTH_KANA_MAP.keys());\n  const turbidityKanaPattern = _ts_buildPattern(_TS_TURBIDITY_KANA_MAP.keys());\n  let errorChar = null;\n  // ひらがな→全角カタカナ\n  let work = str.replace(/[\\u3041-\\u3096]/g, (char) =>\n    String.fromCodePoint(char.charCodeAt(0) + 0x60)\n  );\n  // 半角カタカナ→全角カタカナ\n  work = work.replace(fullWidthKanaPattern, (char) => _TS_FULL_WIDTH_KANA_MAP.get(char) ?? char);\n  // 合成濁点・半濁点（カ゛→ガ等）を変換\n  work = work.replace(turbidityKanaPattern, (pair) => _TS_TURBIDITY_KANA_MAP.get(pair) ?? pair);\n  // 変換後に全角カタカナ以外が含まれていればエラー（ただし変換テーブルの値は許容）\n  const allowedValues = Object.values(_TS_CONVERT_CHARACTER_LIST.fullWidthKana);\n  for (const char of work) {\n    const code = char.charCodeAt(0);\n    // allowedValuesに含まれるか、全角カタカナ範囲なら許容\n    if (!allowedValues.includes(char) && !(code >= 0x30a1 && code <= 0x30fa)) {\n      if (throwOnError) {\n        errorChar = char;\n        break;\n      }\n    }\n  }\n  if (errorChar) throw new Error(`全角カタカナ以外の文字が含まれています: ${errorChar}`);\n  return work;\n};\n\n/**\n * 文字列の中の各文字を全角文字列に変換する関数\n * @param {string} str 変換対象の文字列\n * @param {boolean} [throwOnError=true] 変換不能文字があった場合に例外を投げるか（true:投げる, false:そのまま返す）\n * @returns {string} 変換後の文字列\n * @throws {Error} 変換不能文字が含まれる場合（throwOnError=true時）\n */\nconst toFullWidth = (str = '', throwOnError = true) => {\n  if (!_ts_checkString(str)) throw new Error('変換対象は文字列である必要があります');\n  if (!_ts_checkBoolean(throwOnError))\n    throw new Error('throwOnErrorはboolean型である必要があります');\n  if (!str) throw new Error('変換対象の文字列が空です');\n  try {\n    let errorChar = null;\n    // 半角カタカナの連続部分をまとめて変換\n    const replaced = str.replace(/([\\uFF61-\\uFF9F]+)/g, (kana) => {\n      try {\n        return toFullWidthKatakana(kana, throwOnError);\n      } catch (_e) {\n        if (throwOnError) errorChar = kana;\n        return kana;\n      }\n    });\n    const fullWidthStr = [...replaced]\n      .map((char) => {\n        const code = char.charCodeAt(0);\n        // ひらがなはそのまま\n        if (code >= 0x3041 && code <= 0x3096) {\n          return char;\n        }\n        // バックスラッシュ→円マーク\n        if (char === '\\\\') return '￥';\n        // チルダ→全角チルダ\n        if (char === '~') return '～';\n        // 半角英数字・記号\n        if (code >= 0x21 && code <= 0x7e) {\n          return String.fromCodePoint(code + 0xfee0);\n        }\n        if (char === ' ') return '\\u3000'; // 半角スペースを全角に\n        // 変換後が半角カナ・その他半角文字の場合はエラーまたはそのまま\n        if (!_ts_isFullWidthChar(char)) {\n          if (throwOnError) errorChar = char;\n          // throwOnError=falseならそのまま返す\n        }\n        return char;\n      })\n      .join('');\n    if (errorChar) throw new Error(`全角文字に変換不能な文字が含まれています: ${errorChar}`);\n    return fullWidthStr;\n  } catch (error) {\n    throw error;\n  }\n};\n\n/**\n * 文字列を全角ひらがなに変換する関数\n * @param {string} str 変換対象の文字列\n * @param {boolean} [throwOnError=true] 変換不能な文字があった場合にエラーを投げるかどうか\n * @returns {string} 可能な限り全角ひらがなに変換した文字列\n * @throws {Error} 変換不能な文字が含まれている場合（throwOnError=true時）\n */\nconst toFullWidthHiragana = (str = '', throwOnError = true) => {\n  if (!_ts_checkString(str)) throw new Error('変換対象は文字列である必要があります');\n  if (!_ts_checkBoolean(throwOnError))\n    throw new Error('throwOnErrorはboolean型である必要があります');\n  if (!str) throw new Error('変換対象の文字列が空です');\n  // 半角カタカナ→全角カタカナ\n  let work = toFullWidthKatakana(str, false);\n  // 全角カタカナ→ひらがな\n  work = work.replace(/[\\u30A1-\\u30F6]/g, (char) =>\n    String.fromCodePoint(char.charCodeAt(0) - 0x60)\n  );\n  let errorChar = null;\n  // 変換後にひらがな以外が残っていればエラー\n  for (const char of work) {\n    const code = char.charCodeAt(0);\n    // ひらがなUnicode範囲、または全角スペースなら許容\n    if (!(code >= 0x3041 && code <= 0x3096) && char !== '\\u3000') {\n      if (throwOnError) {\n        errorChar = char;\n        break;\n      }\n    }\n  }\n  if (errorChar) throw new Error(`ひらがな以外の文字が含まれています: ${errorChar}`);\n  return work;\n};\n\n/**\n * 文字列を半角カタカナに変換する関数\n * @param {string} str 変換対象の文字列\n * @param {boolean} [throwOnError=true] 変換不能な文字があった場合にエラーを投げるかどうか\n * @returns {string} 可能な限り半角カタカナに変換した文字列\n * @throws {Error} 変換不能な文字が含まれている場合（throwOnError=true時）\n */\nconst toHalfWidthKana = (str = '', throwOnError = true) => {\n  if (!_ts_checkString(str)) throw new Error('変換対象は文字列である必要があります');\n  if (!_ts_checkBoolean(throwOnError))\n    throw new Error('throwOnErrorはboolean型である必要があります');\n  if (!str) throw new Error('変換対象の文字列が空です');\n  // ひらがな→カタカナ変換を追加\n  const katakanaStr = toFullWidthKatakana(str, false);\n  const halfWidthKanaPattern = _ts_buildPattern(_TS_HALF_WIDTH_KANA_MAP.keys());\n  let errorChar = null;\n  const result = katakanaStr.replace(\n    halfWidthKanaPattern,\n    (char) => _TS_HALF_WIDTH_KANA_MAP.get(char) ?? char\n  );\n  // 変換後に半角カタカナ以外が含まれていればエラー（ただし変換テーブルの値は許容）\n  const allowedValues = Object.values(_TS_CONVERT_CHARACTER_LIST.halfWidthKana);\n  for (const char of result) {\n    if (!allowedValues.includes(char)) {\n      if (throwOnError) {\n        errorChar = char;\n        break;\n      }\n    }\n  }\n  if (errorChar) throw new Error(`半角カタカナ以外の文字が含まれています: ${errorChar}`);\n  return result;\n};\n\n/**\n * 文字列の中の各文字を半角文字（英数字・記号・スペース含む）に変換する関数\n * @param {string} str 変換対象の文字列\n * @param {boolean} [throwOnError=true] 変換不能な文字があった場合にエラーを投げるかどうか\n * @returns {string} 半角文字に変換した文字列\n * @throws {Error} 変換不能な文字が含まれている場合（throwOnError=true時）\n */\nconst toHalfWidth = (str = '', throwOnError = true) => {\n  if (!_ts_checkString(str)) throw new Error('変換対象は文字列である必要があります');\n  if (!_ts_checkBoolean(throwOnError))\n    throw new Error('throwOnErrorはboolean型である必要があります');\n  if (!str) throw new Error('変換対象の文字列が空です');\n  const hyphenProcessed = str.replace(_TS_HYPHEN_REGEX, '-');\n  try {\n    const halfWidthKana = toHalfWidthKana(hyphenProcessed, false);\n    let errorChar = null;\n    const halfWidthStr = [...halfWidthKana]\n      .map((char) => {\n        const code = char.charCodeAt(0);\n        // 半角英数字・記号・スペース・カナ以外は変換不能とみなす\n        // 全角円マーク→半角バックスラッシュ\n        if (char === '￥') return '\\\\';\n        // 全角チルダ→半角チルダ\n        if (char === '～') return '~';\n        if (\n          code >= 0xff01 &&\n          code <= 0xff5e // 全角記号・英数字\n        ) {\n          return String.fromCodePoint(code - 0xfee0);\n        }\n        if (char === '\\u3000') return ' '; // 全角スペースを半角に\n        // 変換後が全角カナ・ひらがな・漢字・その他全角文字の場合はエラーまたはそのまま\n        if (_ts_isFullWidthChar(char)) {\n          if (throwOnError) errorChar = char;\n          // throwOnError=falseならそのまま返す\n        }\n        return char;\n      })\n      .join('');\n    if (errorChar) throw new Error(`半角文字に変換不能な文字が含まれています: ${errorChar}`);\n    return halfWidthStr;\n  } catch (error) {\n    throw error;\n  }\n};\n\n/**\n * メールアドレスの表記を半角文字に変換し、RFC 5322に基づいた形式であるかを判定し、正しくない場合は例外を投げる関数\n * @param {string} emailAddress\n * @returns {string} 正常な場合は変換済みメールアドレス\n * @throws {Error} 不正な場合は例外\n */\nconst assertEmailAddress = (emailAddress = '') => {\n  // 簡易的なRFC5322準拠の正規表現（一般的な用途で十分）\n  const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n  if (!_ts_checkString(emailAddress)) throw new Error('メールアドレスは文字列である必要があります');\n  if (!emailAddress) throw new Error('メールアドレスが空です');\n  const trimmed = emailAddress.trim();\n  try {\n    const singleByteCharacters = toHalfWidth(trimmed);\n    if (/\\.\\.|^\\.|\\.@|@\\.|\\.$/.test(singleByteCharacters))\n      throw new Error('メールアドレスは連続ドットや@直前・直後のドットを含めることはできません');\n    if (!emailPattern.test(singleByteCharacters))\n      throw new Error('メールアドレスの形式が正しくありません');\n    return singleByteCharacters.toLowerCase();\n  } catch (error) {\n    throw error;\n  }\n};\n\n// 公開\nif (typeof window !== 'undefined') {\n  window.isSingleByteAlnumOnly = isSingleByteAlnumOnly;\n  window.toFullWidthKatakana = toFullWidthKatakana;\n  window.toFullWidth = toFullWidth;\n  window.toFullWidthHiragana = toFullWidthHiragana;\n  window.toHalfWidthKana = toHalfWidthKana;\n  window.toHalfWidth = toHalfWidth;\n  window.assertEmailAddress = assertEmailAddress;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/issiki_sigeo/Library/CloudStorage/OneDrive-公益社団法人神奈川県社会福祉士会/ドキュメント/kintone/アプリ開発/my-first-static-web-app/src/vc-check.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/issiki_sigeo/Library/CloudStorage/OneDrive-公益社団法人神奈川県社会福祉士会/ドキュメント/kintone/アプリ開発/my-first-static-web-app/src/zip-code-address-utils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/issiki_sigeo/Library/CloudStorage/OneDrive-公益社団法人神奈川県社会福祉士会/ドキュメント/kintone/アプリ開発/my-first-static-web-app/src/zipcode_processing.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]